---
title: Lua interface
---

Cartesi Machines are instantiated from a simple configuration structure.
This structure defines both the *organization* of the machine (i.e., the amount of RAM, the number of flash drives, their starts and lengths) and the initial *contents* of the machine state (i.e, the value of each register, and the contents of ROM, RAM, and the flash drives).

### Initialization

<div class="row">
<div class="col col--6">

<a name="machine_config"></a>

```lua
machine_config = {
  rom = rom_config,
  ram = ram_config,
  flash = {
    flash_config, -- flash drive 0
    flash_config, -- flash drive 1
    ...
    flash_config  -- flash drive n <= 7
  },
  processor = processor_config,
  clint = clint_config,
  htif = htif_config
}
```

<a name="rom_config"></a>

```lua
rom_config = {
    bootargs = string,
    backing = string
}
```

<a name="ram_config"></a>

```lua
ram_config = {
    length = number,
    backing = string
}
```

<a name="flash_config"></a>

```lua
flash_config = {
  start = number,
  length = number,
  backing = string,
  shared = boolean
}
```

<a name="htif_config"></a>

```lua
htif_config = {
    interact = boolean,
    yield = boolean
    fromhost = number,
    tohost = number,
}
```

<a name="clint_config"></a>

```lua
clint_config = {
    mtimecmp = number,
}
```
</div>
<div class="col col--6">

<a name="processor_config"></a>

```lua
processor_config = {
  x = {
    [1] = number, -- register x1
    [2] = number, -- register x2
    ...
    [31] = number, -- register x31
  },
  pc = number,
  mvendorid = number,
  marchid = number,
  mimpid = number,
  mcycle = number,
  minstret = number,
  mstatus = number,
  mtvec = number,
  mscratch = number,
  mepc = number,
  mcause = number,
  mtval = number,
  misa = number,
  mie = number,
  mip = number,
  medeleg = number,
  mideleg = number,
  mcounteren = number,
  stvec = number,
  sscratch = number,
  sepc = number,
  scause = number,
  stval = number,
  satp = number,
  scounteren = number,
  ilrsc = number,
  iflags = number
},
```
</div>
</div>

The <a href="#rom_config">`rom`</a> entry in `machine_config` is a table with two fields.
`Bootargs` gives a string of at most 2KiB that will be copied into the last 2KiB of ROM. `Backing` gives the file name of an image that will be loaded at start of ROM.
This is where the [ROM image](machine/ROM.md) generated by the Emulator SDK is typically loaded, and it is here that the processor's `pc` (program counter) starts by default.
This ROM image generates the [<i>devicetree</i>](http://devicetree.org/) that describes the hardware to Linux, passes the `bootargs` string as the kernel command-line parameters, then cedes control to the RAM image.

The <a href="#ram_config">`ram`</a> entry in `machine_config` also has two fields.
`Length` gives the RAM size in bytes (RAM always starts at offset `0x80000000`).
This length should be a multiple of 4Ki, the length of a RISC-V memory page.
`Backing` gives the file name of an image that will be loaded at offset `0x80000000` (i.e., the start of RAM).
This is where the [RAM image](machine/kernel.md) generated by the Emulator SDK (which contains the Berkeley Boot Loader linked with the Linux kernel) is loaded.

The <a href="#flash_config">`flash`</a> entry in `machine_config` is a list containing flash drive configurations.
Each configuration contains four fields.
Fields `start` and `length` give the start and length of the flash drive in the machine's address space. The length must be a
multiple of 4Ki, the length of a memory page. `Backing` gives the file
name of an image that will be <i>mapped</i> to this region. This is different
from the ROM and RAM backing files, which are simply copied into the Cartesi Machine
memory, which has been allocated from the host memory. Flash drives use memory mapping because the backing files can be very large.
Mapping them instead of copying them saves host memory, as well as the time it
would take to load the backing files from disk to host memory. Since flash drive backing files
are mapped, their sizes on disk must exactly match the `length`
of the flash drive they are `backing`.  `Shared` is a Boolean
value that specifies whether changes to the flash drive that happen inside the target reflect
in the backing file that resides in the host as well. If set to `true`, the backing file will be modified accordingly.
This is useful when a flash drive will hold the result of a computation.
If set to `false` (the default), target modifications to the flash drive are <i>not</i> propagated to the
backing file that resides in the host. I.e., even though the flash drives are
read/write from the target perspective, the backing file in the host is left
unmodified.

The <a href="#htif_config">`htif`</a> entry in `machine_config`
has four fields, two of which are used only in rare occasions.  The most
commonly used field is the Boolean `interact`. When set to `true`
(the default is `false`), it instructs the emulator to monitor terminal
input in the host and make it available to the target via the HTIF device. This
is useful in interactive sessions during prototyping, and should never be used
when verifiability is needed. The `yield` Boolean instructs the emulator
to honor commands by the Yield subdevice in HTIF, returning control to the host.
This is used as a means for applications running in the target to inform the host about their progress.
When set to `false` (the default), the emulator ignores yield commands
and continues execution without returning control to the host.

The other entries in the `machine_config` are used only in rare
occasions.
The devices and processor have a variety of control and status registers (CSRs),
in addition to processor's general-purpose registers.
Most of these are defined in the RISC-V [user-level
ISA](https://content.riscv.org/wp-content/uploads/2017/05/riscv-spec-v2.2.pdf) and [privileged
architecture](https://content.riscv.org/wp-content/uploads/2017/05/riscv-privileged-v1.10.pdf) specifications.
The Cartesi-specific additions are described under the [the target perspective](#the-target-perspective).

The fields `tohost` and `fromhost` in `htif`.
allow for the overriding of the default initial values of these CSRs.
The <a href="#clint_config">`clint`</a> entry has a single
field, `mtimecmp`, which allows for the overriding of the default initial value
of this CSR. Similarly, the fields in the <a href="#processor_config">`processor`</a> entry
in `machine_config` allow for the overriding of the default initial value of all
general-purpose registers and CSRs.

#### Using cartesi-machine to produce configurations

The command-line utility can be used to streamline the configuration of Cartesi Machines.
Recall from an [earlier example](#first-cartesi-machine-example) that the `cartesi-machine` command
```bash
$ cartesi-machine \
    --rom-backing="rom.bin" \
    --append-rom-bootargs="quiet -- /bin/ls /bin" \
    --ram-backing="kernel.bin" \
    --ram-length=64Mi \
    --root-backing="rootfs.ext2" \
    --max-mcycle=0 \
    --dump-machine-config
```
builds a Cartesi Machine with `rom.bin` as the [ROM image](machine/ROM.md), and to append the string `quiet -- /bin/ls /bin` to the automatically generated kernel command line.
The machine has 64MiB of RAM, uses `kernel.bin` as the [RAM image](machine/kernel.md), and uses `rootfs.ext2` as the [root file-system](machine/rootfs.md).
(These files are generated by the Emulator SDK.)
The last two options instruct the utility to stop execution at cycle 0 (`mcycle` in `--max-mcycle` refers to the CSR that is advanced at every clock cycle), i.e., before the machine even starts and dump the resulting configuration.

The output of the command is
```lua
Building machine: please wait
machine_config = {
  processor = {
    x = {
      0x0, -- default
      0x0, -- default
      0x0, -- default
      0x0, -- default
      0x0, -- default
      0x0, -- default
      0x0, -- default
      0x0, -- default
      0x0, -- default
      0x0, -- default
      0x0, -- default
      0x0, -- default
      0x0, -- default
      0x0, -- default
      0x0, -- default
      0x0, -- default
      0x0, -- default
      0x0, -- default
      0x0, -- default
      0x0, -- default
      0x0, -- default
      0x0, -- default
      0x0, -- default
      0x0, -- default
      0x0, -- default
      0x0, -- default
      0x0, -- default
      0x0, -- default
      0x0, -- default
      0x0, -- default
      0x0, -- default
    },
    iflags = 0x18, -- default
    ilrsc = 0xffffffffffffffff, -- default
    marchid = 0x2, -- default
    mcause = 0x0, -- default
    mcounteren = 0x0, -- default
    mcycle = 0x0, -- default
    medeleg = 0x0, -- default
    mepc = 0x0, -- default
    mideleg = 0x0, -- default
    mie = 0x0, -- default
    mimpid = 0x1, -- default
    minstret = 0x0, -- default
    mip = 0x0, -- default
    misa = 0x8000000000141101, -- default
    mscratch = 0x0, -- default
    mstatus = 0xa00000000, -- default
    mtval = 0x0, -- default
    mtvec = 0x0, -- default
    mvendorid = 0x6361727465736920, -- default
    pc = 0x1000, -- default
    satp = 0x0, -- default
    scause = 0x0, -- default
    scounteren = 0x0, -- default
    sepc = 0x0, -- default
    sscratch = 0x0, -- default
    stval = 0x0, -- default
    stvec = 0x0, -- default
  },
  ram = {
    length = 0x4000000,
    backing = "kernel.bin",
  },
  rom = {
    backing = "rom.bin",
    bootargs = "console=hvc0 rootfstype=ext2 root=/dev/mtdblock0 rw mtdparts=flash.0:-(root) quiet -- /bin/ls /bin",
  },
  htif = {
    tohost = 0x0, -- default
    fromhost = 0x0, -- default
    interact = false, -- default
    yield = false, -- default
  },
  clint = {
    mtimecmp = 0x0, -- default
  },
  flash = {
    {
      start = 0x8000000000000000,
      length = 0x3c00000,
      backing = "rootfs.ext2",
      shared = false, -- default
    },
  },
}

Cycles: 0
```

This output includes a number of default values, conveniently marked as such by the `cartesi-machine` utility.
Reduced to its essential, it is simply
```lua
Building machine: please wait
machine_config = {
  processor = {
    mvendorid = cartesi.machine.MVENDORID,
    mimpid = cartesi.machine.MIMPID,
    marchid = cartesi.machine.MARCHID,
  },
  ram = {
    length = 0x4000000,
    backing = "kernel.bin",
  },
  rom = {
    backing = "rom.bin",
    bootargs = "console=hvc0 rootfstype=ext2 root=/dev/mtdblock0 rw mtdparts=flash.0:-(root) quiet -- /bin/ls /bin",
  },
  flash = {
    {
      start = 0x8000000000000000,
      length = 0x3c00000,
      backing = "rootfs.ext2",
    },
  },
}
```
The only required values in the `processor` configuration are the `mvendorid`, `mimpid`, `marchid` CSRs.
These are used to ensure the emulator matches the configuration.
During prototyping, they can be filled out from values exposed by the emulator itself.
In production code, they should be hard-coded to match the release of the emulator in use.

Note how the utility automatically sets the ROM `bootargs` to include several options in addition to what was requested by the `--append-rom-bootargs` option.
In particular, the `mtdparts=flash.0:-(root)` section is a kernel command-line parameter that informs the kernel of flash drives partitioning information.
The format for the option is documented in the [source-code](https://elixir.bootlin.com/linux/v5.5.4/source/drivers/mtd/parsers/cmdlinepart.c) for the kernel module that reads the parameter.
Here, `(root)` gives the partition label.

Recall the command-line utility can run Cartesi Machines with additional drives.
In that case, the resulting configuration automatically includes the appropriate value for `mtdparts`.
Repeating another [earlier example](#cartesi-machine-with-foo-flash-drive), and again omitting default values,
```bash
$ mkdir foo
$ echo Hello world > foo/bar
$ genext2fs -b 1024 -d foo foo.ext2
$ cartesi-machine \
    --append-rom-bootargs="quiet -- /bin/cat /mnt/foo/bar.txt" \
    --flash-foo-backing="foo.ext2" \
    --max-mcycle=0 \
    --dump-machine-config
```
produces the configuration
```lua
machine_config = {
  processor = {
    mvendorid = cartesi.machine.MVENDORID,
    mimpid = cartesi.machine.MIMPID,
    marchid = cartesi.machine.MARCHID,
  },
  ram = {
    length = 0x4000000,
    backing = "kernel.bin",
  },
  rom = {
    backing = "rom.bin",
    bootargs = "console=hvc0 rootfstype=ext2 root=/dev/mtdblock0 rw mtdparts=flash.0:-(root);flash.1:-(foo) quiet -- /bin/cat /mnt/foo/bar.txt",
  },
  flash = {
    {
      start = 0x8000000000000000,
      length = 0x3c00000,
      backing = "rootfs.ext2",
    },
    {
      start = 0x9000000000000000,
      length = 0x100000,
      backing = "foo.ext2",
    },
  },
}
```
Note the entry in `mtdparts` that causes `flash.1`, the flash drive containing the `foo.ext2` file-system to receive label `(foo)`.

#### Instantiating, obtaining state hashes, and running Cartesi Machines

The Lua interface to `cartesi.machine` can be used to instantiat and run a Cartesi Machine based on any desired configuration.
In particular, the configurations produced by the `cartesi-machine` utility, such as the configuration above.
This is, after all, the interface used internally by the `cartesi-machine` utility.
The following script serves to illustrate the basic operation.
```lua
-- Load the Cartesi Lua module
local cartesi = require"cartesi"

-- Writes formatted text to stderr
local function stderr(fmt, ...)
	io.stderr:write(string.format(fmt, ...))
end

-- Converts hash from binary to hexadecimal string
local function hexhash(hash)
    return (string.gsub(hash, ".", function(c)
        return string.format("%02x", string.byte(c))
    end))
end

-- Machine configuration with the foo.ext2 flash drive
local machine_config = {
  processor = {
    mvendorid = cartesi.machine.MVENDORID,
    mimpid = cartesi.machine.MIMPID,
    marchid = cartesi.machine.MARCHID,
  },
  ram = {
    length = 0x4000000,
    backing = "kernel.bin",
  },
  rom = {
    backing = "rom.bin",
    bootargs = "console=hvc0 rootfstype=ext2 root=/dev/mtdblock0 rw mtdparts=flash.0:-(root);flash.1:-(foo) quiet -- /bin/cat /mnt/foo/bar.txt",
  },
  flash = {
    {
      start = 0x8000000000000000,
      length = 0x3c00000,
      backing = "rootfs.ext2",
    },
    {
      start = 0x9000000000000000,
      length = 0x100000,
      backing = "foo.ext2",
    },
  },
}

-- Instantiate the machine
stderr("Building machine: please wait\n")
local m = cartesi.machine(machine_config)

-- Print the initial hash
stderr("Updating Merkle tree: please wait\n")
m:update_merkle_tree()
print(hexhash(m:get_root_hash()))

-- Run machine util it halts (or the heat death of the universe)
local max_mcycle = math.maxinteger
m:run(max_mcycle)

-- Check if machine was halted and print actual cycle count
if m:read_iflags_H() then
	stderr("\nHalted!\n")
	stderr("Cycles: %u\n", m:read_mcycle())
else
	stderr("\nNot halted yet!\n")
end

-- Print the final hash
stderr("Updating Merkle tree: please wait\n")
m:update_merkle_tree()
print(hexhash(m:get_root_hash()))
```
In the example above, the `cartesi.machine` constructor is invoked with the `machine_config` configuration table.
This returns a machine instance `m`, ready to run.
Before running the machine, however, the script computes and prints the state hash.

State hashes are maintained in a lazy fashion.
If no state hashes are needed, negligible cost is incurred.
The performance pentalty imposed on the emulator, should it be required to keep state hashes up-to-date, would be unacceptable (by several orders of magnitude).
Before requesting a state hash, the method `m:update_merkle_tree()` must be called.
It goes over all changes to the state that are still unnacounted for since the tree was last updated, and brings the tree in sync with the state.
Immediately after the call to `m:update_merkle_tree()`, state hashes are valid.
The script then obtains the root hash with the `m:get_root_hash()` method.
This returns a 32-byte binary hash, which is converted to hexadecimal and printed to screen.
The value can be used to ensure the machine created by the script indeed matches the machine created by the `cartesi-machine` utility.

The script then executes the machine with the `m:run(<max_mcycle>)` method.
The value of `<max_mcycle>` used in the example is a very large integer, providing the machine with enough cycles to run until it halts.

Once `m:run()` returns, the script checks the `H` bit in the `iflags` CSR.
This bit is permanently set to `true` if and only if the machine halts.
If indeed the machine is halted, the script then prints the total number of cycles executed, by reading the `mcycle` CSR.
This register is advanced at every cycle and, according to the configuration, started at `0`.

The output on the left was generated by the script.
The output on the right was produced by running the same Cartesi Machine via the `cartesi-machine` utility.
```bash
$ cartesi-machine \
    --append-rom-bootargs="quiet -- /bin/cat /mnt/foo/bar.txt" \
    --flash-foo-backing="foo.ext2" \
    --initial-hash
```
<div class="row">
<div class="col col--6">

```
Building machine: please wait
Updating Merkle tree: please wait
bda898196723afe437c8de8bcb8aebd08ca7f4e44452bcf58d2fc9e93a12dac3

         .
        / \
      /    \
\---/---\  /----\
 \       X       \
  \----/  \---/---\
       \    / CARTESI
        \ /   MACHINE
         '

Hello world!
[    0.059265] reboot: Power down

Halted!
Cycles: 64291620
Updating Merkle tree: please wait
c6c0e6fe92f443e6b17f34c0e4479f0b7c169242329d94a56955d39db0fb2463
```

</div>
<div class="col col--6">

```
Building machine: please wait
Updating Merkle tree: please wait
bda898196723afe437c8de8bcb8aebd08ca7f4e44452bcf58d2fc9e93a12dac3

         .
        / \
      /    \
\---/---\  /----\
 \       X       \
  \----/  \---/---\
       \    / CARTESI
        \ /   MACHINE
         '

Hello world!
[    0.059265] reboot: Power down

Halted with payload: 0
Cycles: 64291620
Updating Merkle tree: please wait
c6c0e6fe92f443e6b17f34c0e4479f0b7c169242329d94a56955d39db0fb2463
```

</div>
</div>

Note that the initial and final hashes are the same, as expected.

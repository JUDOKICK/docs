---
title: Command-line interface
---

In the simplest usage scenario, the `cartesi-machine` command-line utility can be used to run a Cartesi Machine until it halts.

### Initialization

<a name="first-cartesi-machine-example"></a>

The following command instructs `cartesi-machine` to build a Cartesi Machine with `rom.bin` as the [ROM image](machine/ROM.md), and to append the string `quiet` to the automatically generated kernel command line.
The machine has 64MiB of RAM, uses `kernel.bin` as the [RAM image](machine/kernel.md), and uses `rootfs.ext2` as the [root file-system](machine/rootfs.md).
(The `rom.bin`, `kernel.bin`, and `rootfs.ext2` files are generated by the Emulator SDK.)
Once initialization is complete, the machine executes the command `/bin/ls /bin` and exits.

```bash
diego@playground $ cartesi-machine \
    --rom-image="/opt/cartesi/share/images/rom.bin" \
    --append-rom-bootargs="quiet" \
    --ram-image="/opt/cartesi/share/images/kernel.bin" \
    --ram-length=64Mi \
    --flash-drive="label:root,filename:/opt/cartesi/share/images/rootfs.ext2"
    -- /bin/ls /bin
```
The `--rom-image`, `--ram-image`, `--ram-length`, and `--flash-drive` command-line options have as default values the same values in the example, so they can be omitted.
To remove the default backing files, use the command-line options `--no-ram-image` and `--no-root-flash-drive`, respectively.

```bash
diego@playground $ cartesi-machine --append-rom-bootargs="quiet" -- /bin/ls /bin
```
The output is
```
Building machine: please wait

         .
        / \
      /    \
\---/---\  /----\
 \       X       \
  \----/  \---/---\
       \    / CARTESI
        \ /   MACHINE
         '

arch           dmesg          linux32        netstat        setserial
ash            dnsdomainname  linux64        nice           sh
base64         dumpkmap       ln             nuke           sleep
busybox        echo           login          pidof          stty
cat            egrep          ls             ping           su
chattr         false          lsattr         pipe_progress  sync
chgrp          fdflush        lsblk          printenv       tar
chmod          fgrep          mk_cmds        ps             touch
chown          findmnt        mkdir          pwd            true
compile_et     getopt         mknod          resume         umount
cp             grep           mktemp         rm             uname
cpio           gunzip         more           rmdir          usleep
cttyhack       gzip           mount          run-parts      vi
date           hostname       mountpoint     sed            watch
dd             kill           mt             setarch        wdctl
df             link           mv             setpriv        zcat
[    0.055690] reboot: Power down

Halted with payload: 0
Cycles: 60547848
```
The output shows the Cartesi Machine splash screen, followed by the listing of directory `/bin`.
The `quiet` option in ROM `bootargs` instructs the Linux kernel to omit a variety of diagnostic messages that would otherwise clutter the output.
The listing was produced by the command that follows `--` separator in the command line.
The Linux passes this unmodified to `/sbin/init`, and the Cartesi-provided `/sbin/init` script executes the command before gracefully halting the machine.

### Interactive sessions

By default, the `cartesi-machine` utility executes the Cartesi Machine non-interactive mode.
Verifiable computations must always be run in non-interactive sessions.
User interaction with a Cartesi Machine via the console is, after all, not reproducible.
Nevertheless, during development, it is often convenient to directly interact with the emulator, as if using a computer console.

The command-line option `-i` (short for `--htif-console-getchar`) instructs the emulator to monitor the console for input, and to make this input available to the Linux kernel via the HTIF device (HTIF stands for Host-Target Interface.)
Typically, this option will be used in conjunction with the `--` separator and the command `/bin/sh`, causing the Cartesi-provided `/sbin/init` script to drop into an interactive shell.
Interaction with the shell enables the exploration of the embedded Linux distribution from the inside.
Exiting the shell returns control back to `/sbin/init`, which then gracefully halts the machine.

For example, if an interactive session is started with the following command
```bash
diego@playground $ cartesi-machine \
    --append-rom-bootargs="quiet" \
    -i -- /bin/sh
```
it drops into the shell.
Running the command `ls /bin` causes the listing of directory `/bin` to appears.
The command `exit` causes the shell to exit.
The output is
```
Building machine: please wait
Running in interactive mode!

         .
        / \
      /    \
\---/---\  /----\
 \       X       \
  \----/  \---/---\
       \    / CARTESI
        \ /   MACHINE
         '

~ # ls /bin
arch           dnsdomainname  linux64        nice           sh
ash            dumpkmap       ln             nuke           sleep
base64         echo           login          pidof          stty
busybox        egrep          ls             ping           su
cat            false          lsattr         pipe_progress  sync
chattr         fdflush        lsblk          printenv       tar
chgrp          fgrep          mk_cmds        ps             touch
chmod          findmnt        mkdir          pwd            true
chown          getopt         mknod          resume         umount
compile_et     grep           mktemp         rm             uname
cp             gunzip         more           rmdir          usleep
cpio           gzip           mount          run-parts      vi
date           hostname       mountpoint     sed            watch
dd             kill           mt             setarch        wdctl
df             link           mv             setpriv        zcat
dmesg          linux32        netstat        setserial
~ # exit
[  339.117447] reboot: Power down

Halted with payload: 0
Cycles: 339122301929
```
Note that the final cycle count is meaningless, as the machine repeatedly skips cycles forward when idle from one CLINT-generated interrupt to the next (CLINT stands for Core Local Interruptor, the timer device).

### Adding custom flash drives

To enable transparency, Cartesi Machine flash drives are mapped into the machine's 64-bit address space.
By default, the start of the first flash drive (the root) is set to the beginning of the second half of the address space (i.e., at offset 2<sup>63</sup>).
The size of a flash drive is automatically set to match the size of its backing file.
Because RISC-V uses 4KiB pages, backing files must have a size multiple of 4KiB.
(The `truncate` utility can be used to pad a file with zeros so its size is a multiple of 4KiB.)

Other flash drives (up to 8 in total) can be specified by adding a command-line option in the form `--flash-<label>-backing=<filename>`.
The starts of the 8 flash drives are automatically spaced uniformly within that second half of the address space.  They are therefore separated by 2<sup>60</sup> bytes, which &ldquo;should be enough separation for everyone&rdquo;.

Choosing convenient starts and length for flash drives in the machine's address space has implications on certain operations, discussed in detail from [the blockchain perspective](#the-blockchain-perspective), that involve the manipulation of hashes of the Cartesi Machine state.
The start and length of a flash drive with label `<foo>` can be explicitly specified in the command line with the options `--flash-<label>-start=<number>` and `--flash-<label>-length=<number>`.
For convenience, numbers can be specified in decimal or hexadecimal (e.g., `4096` or `0x1000`) and may include a suffix multiplier (i.e., `Ki` to multiply by 2<sup>10</sup>, `Mi` to multiply by 2<sup>20</sup>, and `Gi` to multiply by 2<sup>30</sup>).
They can also use C's *shift left* notation to multiply by arbitrary powers of 2 (e.g. `1 << 24` meaning 2<sup>24</sup>).
If the start of *any* drive is specified, then the starts for *all* drives must be specified.
The machine will fail to build if there is any overlap between the ranges occupied by multiple drives.

The preferred file-system type is `ext2`.
These file-systems can be easily created with the `genext2fs` command-line utility (available in Ubuntu as its own package), and inspected or modified with the `e2ls`, `e2cp` command-line utilities (available in Ubuntu as the `e2tools` package). <a name="cartesi-machine-with-foo-flash-drive"></a>

For example,
```bash
diego@playground $ mkdir foo
diego@playground $ echo Hello world > foo/bar
diego@playground $ genext2fs -b 1024 -d foo foo.ext2
diego@playground $ cartesi-machine \
    --append-rom-bootargs="quiet -- /bin/cat /mnt/foo/bar.txt" \
    --flash-foo-backing="foo.ext2"
```
Here, the string `foo` is the *label* for the flash drive.
The Cartesi-provided `/sbin/init` script will automatically mount this file-system (if indeed the backing file contains a valid file-system) at `/mnt/foo`.
The command executed in the machine simply copies its contents to the terminal.
The output is
```
Building machine: please wait

         .
        / \
      /    \
\---/---\  /----\
 \       X       \
  \----/  \---/---\
       \    / CARTESI
        \ /   MACHINE
         '

Hello world!
[    0.059029] reboot: Power down

Halted with payload: 0
Cycles: 64054884
```

### Making target changes to flash drives reflect on the backing files

The emulator never modifies the ROM and RAM backing files.
They are simply loaded into host memory and only this copy is exposed to changes caused by code executing in the target.
(The `--dump-pmas` command-line option can be used to inspect the modified copies for debugging purposes. See below.)

By default, the emulator also does not modify the backing files for any of the flash drives.
However, since these backing files can be very large, the emulator does not pre-allocate any host memory for flash drives.
Instead, it uses the operating system's memory mapping capabilities.
The operating system reads to host memory only those pages in the backing file that are actually read by code executing in the target.
(Naturally, when a state hash is requested, all backing files are read from disk and processed. See below.)
These backing files are mapped to host memory in a *copy-on-write* fashion.
When code running in the target causes the emulator to write to a mapped backing file, the operating system makes a copy of the page before modification and replaces the mapping to point to it.
The backing files are never written to.
For example, running the machine
```bash
diego@playground $ cartesi-machine \
    --append-rom-bootargs="quiet -- /bin/ls /mnt/foo/*.txt && /bin/cp /mnt/foo/bar.txt /mnt/foo/baz.txt && ls /mnt/foo/*.txt" \
    --flash-foo-backing="foo.ext2"
```
produces the output
```
Building machine: please wait

         .
        / \
      /    \
\---/---\  /----\
 \       X       \
  \----/  \---/---\
       \    / CARTESI
        \ /   MACHINE
         '

/mnt/foo/bar.txt
/mnt/foo/bar.txt  /mnt/foo/baz.txt
[    0.060616] reboot: Power down

Halted with payload: 0
Cycles: 65652775
```
indicating that the file-system was modified, at least from the perspective of the target.
However, inspecting the `foo.ext2` backing file from outside the emulator shows it is unchanged.
```
diego@playground $ e2ls -al foo.ext2:*.txt
     12  100644   501    20       13 19-May-2020 14:48 bar.txt
```

This behavior is appropriate when the flash drives will only be used as inputs.
For output flash drives, target changes to flash drives must reflect on the corresponding backing files.
To that end, the command-line option `--flash-<label>-shared` causes the backing files to be mapped to host memory in a *shared* fashion.
For example,
```bash
diego@playground $ cartesi-machine \
    --append-rom-bootargs="quiet -- /bin/ls /mnt/foo/*.txt && /bin/cp /mnt/foo/bar.txt /mnt/foo/baz.txt && ls /mnt/foo/*.txt" \
    --flash-foo-backing="foo.ext2" \
    --flash-foo-shared
```
produces exactly the same output as before.
However, the backing file `foo.ext2` has indeed been modified.
```
diego@playground $ e2ls -al foo.ext2:*.txt
     12  100644   501    20       13 19-May-2020 14:48 bar.txt
     13  100644     0     0       13 31-Dec-1969 21:00 baz.txt
```

### Controlling the end of execution

Before returning control to the command line, `cartesi-machine` prints the value of *halt payload* and the number of *cycles*.
In the examples shown until now, the payload has always been 0.
This is the default payload produced by the `poweroff` command available inside `rootfs.ext2`, which is invoked by `/sbin/init` during a graceful shutdown.
The `/opt/cartesi/htif` utility can be used to immediately halt the machine, as if pulling its cord from a wall, while at the same time selecting the payload.
The utility uses HTIF halt subdevice (`DEV=0`) to halt the machine and, consequently, the emulator.
For example,
```bash
diego@playground $ cartesi-machine \
    --append-rom-bootargs="quiet -- /opt/cartesi/bin/htif --halt 42"
```
produces the output
```
Building machine: please wait

         .
        / \
      /    \
\---/---\  /----\
 \       X       \
  \----/  \---/---\
       \    / CARTESI
        \ /   MACHINE
         '


Halted with payload: 42
Cycles: 54171835
```

The machine's processor includes a control and status register (CSR), named `mcycle`, that starts at 0 and is incremented after every cycle.
The maximum cycle can be specified with the command-line option `--max-mcycle=<number>`.
For example,
```bash
diego@playground $ cartesi-machine \
    --append-rom-bootargs="quiet -- /opt/cartesi/bin/htif --halt 42" \
    --max-mcycle=696857
```
produces the output
```
Building machine: please wait

         .
        / \
      /    \
\---/---\  /----\
 \       X       \
  \----/  \---/---\
       \    / CARTESI

Cycles: 696857
```
Note the execution was interrupted before the splash screen was completed.

### Providing feedback on the computation progress

A target application can inform the host of its progress by using a Cartesi-specific HTIF yield subdevice (`DEV=2`) progress command (`CMD=0`).
This causes the `cartesi-machine` script to regain control of execution, whereupon it verifies the emulator has yielded control, and prints a progress message using the provided `DATA=<permil>` value.

For example, during the execution of the loop,
```bash
diego@playground $ cartesi-machine
    --append-rom-bootargs="quiet -- /bin/ash -c 'for i in \$(seq 0 50 10000); do /opt/cartesi/bin/htif --yield 0 \$i; done'" \
    --htif-yield
```
the `cartesi-machine` utility receives control back from the emulator every time the target executes the `htif` utility.
Each time, it it prints a progress message (shown at 44% below) and resumes the emulator so it can continue working.
```
Building machine: please wait

         .
        / \
      /    \
\---/---\  /----\
 \       X       \
  \----/  \---/---\
       \    / CARTESI
        \ /   MACHINE
         '

Progress:  44.00
```
This feature is most useful when the emulator is controlled programmatically, via its Lua, C++, or gRPC interfaces, where Cartesi Machines typically run disconnected from the console.
In these situations, the progress command of the yield HTIF device can be used to drive a dynamic user interface element that reassures users progress is being made during long, silent computations.
Its handling by `cartesi-machine`, which does have access to the console, is simply to help with prototyping and debugging.

### Printing machine state hashes

The `cartesi-machine` utility can also be used to output Cartesi Machine state hashes.
To obtain the state hash right before execution starts, use the command-line option `--initial-hash`.
Conversely, to obtain the state hash right after execution is done, use the option `--final-hash`.
For example,
```bash
diego@playground $ cartesi-machine \
    --append-rom-bootargs="quiet -- /opt/cartesi/bin/htif --halt 42" \
    --max-mcycle=696857 \
    --initial-hash \
    --final-hash
```
produces the output
```
Building machine: please wait
Updating Merkle tree: please wait
edb595619409a3f8bc970adc0a3662f8866a31d572b51a56f632815d8ad9e826

         .
        / \
      /    \
\---/---\  /----\
 \       X       \
  \----/  \---/---\
       \    / CARTESI

Cycles: 696857
Updating Merkle tree: please wait
260fc7e3eb959f6908c2649ec94717f770846ca8f7e41890117588404033efa5
```
The initial state hash `edb595...` is the Merkle tree root hash of the entire 64-bit address space, where the leaves are aligned 64-bit words.
Since Cartesi Machines are transparent, the contents of this address space encompass the entire machine state, including the all processor's CSRs and general-purpose registers, the contents of RAM and ROM, of all flash drives, and of all other devices connected to the board.
It therefore works as a cryptographic signature of the machine, and implicitly of the computation it is about to execute.
Since Cartesi Machines are reproducible, the initial state hash also works as a future on the result of the computation itself.
In other words, the the &ldquo;final state hash&rdquo; `260fc7...` is the only possible outcome for the `--final-hash` at cycle 696857, given the result of the `--initial-hash` operation was `edb595...`.

Allowing the machine to run until it halts
```bash
diego@playground $ cartesi-machine \
    --append-rom-bootargs="quiet -- /opt/cartesi/bin/htif --halt 42" \
    --initial-hash \
    --final-hash
```
produces instead the output
```
Building machine: please wait
Updating Merkle tree: please wait
edb595619409a3f8bc970adc0a3662f8866a31d572b51a56f632815d8ad9e826

         .
        / \
      /    \
\---/---\  /----\
 \       X       \
  \----/  \---/---\
       \    / CARTESI
        \ /   MACHINE
         '


Halted with payload: 42
Cycles: 54171835
Updating Merkle tree: please wait
5ab9d827a133adb39fb3e46ce9cc963614d25fbd44c09acdb4881b6eebc640cd
```
Naturally, the initial state hash is the same as before.
However, the final state hash `5ab9d8...` now pertains to cycle 54171835, where the machine is halted.
This is only possible state hash for a halted machine that started from state hash `edb595...`.

### Storing and loading Cartesi Machines

At any point in their execution, Cartesi Machines can be stored to disk.
A stored machine can later be loaded to continue its execution where it left off.
To store a machine to a given `<directory>`, use the command-line option `--store=<directory>`.
The machine is stored in the state it was before `cartesi-machine` returns to the command line.
For example, to store the machine corresponding to state hash `260fc7...`
```bash
$ cartesi-machine \
    --append-rom-bootargs="quiet -- /opt/cartesi/bin/htif --halt 42" \
    --max-mcycle=696857 \
    --store="260fc7"
```
This command creates a directory `260fc7/`, containing a variety of files for internal use by the Cartesi Machine emulator.
If the directory already exists, the operation will fail.
This prevents the overwriting of a Cartesi Machine by mistake.
Once created, the directory can be compressed and transfered to other hosts.
To restore the corresponding Cartesi Machine, use the command-line option `--load=<directory>`.
For example,
```bash
$ cartesi-machine \
    --load="260fc7" \
    --initial-hash \
    --final-hash
```
produces the output
```
Loading machine: please wait
Updating Merkle tree: please wait
260fc7e3eb959f6908c2649ec94717f770846ca8f7e41890117588404033efa5
        \ /   MACHINE
         '


Halted with payload: 42
Cycles: 54171835
Updating Merkle tree: please wait
5ab9d827a133adb39fb3e46ce9cc963614d25fbd44c09acdb4881b6eebc640cd
```
Note that, other than `--load`, no initialization command-line options were used.
These initializations were used to define the machine before it was stored: their values are implicitly encoded in the stored state.
Note also that the initial state hash `260fc7...` after `--load` matches the final state hash before `--store`.
After all, they are state hashes concerning the state of the same machine at the same cycle.
In fact, `--store` writes this state hash inside the directory, and `--load` verifies that the state hash of the restored machine matches what it found in the directory.
Finally, note that the machine continues from where it left off, and reaches the same final state hash `5ab9d8...`, as if it had never been interrupted.

### Advanced options

The remaining options in the command-line utility `cartesi-machine` are mostly used for low-level debugging.
As such, they require some context.
During verification, the blockchain mediates a *verification game* between the disputing parties.
Both parties started from a Cartesi Machine that has a known and agreed uppon initial state hash.
At the end of the computation, these parties now disagree on the state hash for the halted machine.
The state hash evolves as the machine executes steps in its fetch-execute loop.
The first stage of the verification game therefore searches for the first step of disagreement: the particular cycle such that the parties agree on the state hash before the step, but disagree on the state hash after the step.
Once this step is identified, one of the parties sends to the blockchain a log of state accesses that happen along the step, including cryptographic proofs for every value read from or written to the state.
This log proves to the blockchain that the execution of the step evolves the state in such a way that it reaches the state hash claimed by the submitting party.
The `--step` command-line option instructs `cartesi-machine` to dump to screen an abridged, user-friendly version of this state access log.

For the sake of completeness, assuming the step in question is `696857` (the same used in the examples above) running
```bash
$ cartesi-machine \
    --append-rom-bootargs="quiet -- /opt/cartesi/bin/htif --halt 42" \
    --max-mcycle=696857 \
    --step > /dev/null
```
produces the log
```
Building machine: please wait

Cycles: 696857
Gathering step proof: please wait
begin step
  hash 260fc7e3
  1: read iflags.H@0x1d0(464): 0x18(24)
  hash 260fc7e3
  2: read iflags.Y (superfluous)@0x1d0(464): 0x18(24)
  hash 260fc7e3
  3: write iflags.Y@0x1d0(464): 0x18(24) -> 0x18(24)
  begin raise_interrupt_if_any
    hash 260fc7e3
    4: read mip@0x170(368): 0x0(0)
    hash 260fc7e3
    5: read mie@0x168(360): 0x8(8)
  end raise_interrupt_if_any
  begin fetch_insn
    hash 260fc7e3
    6: read pc@0x100(256): 0x80002e8c(2147495564)
    begin translate_virtual_address
      hash 260fc7e3
      7: read iflags.PRV@0x1d0(464): 0x18(24)
      hash 260fc7e3
      8: read mstatus@0x130(304): 0xa00001800(42949679104)
    end translate_virtual_address
    begin find_pma_entry
      hash 260fc7e3
      9: read pma.istart@0x800(2048): 0x800000f9(2147483897)
      hash 260fc7e3
      10: read pma.ilength@0x808(2056): 0x4000000(67108864)
    end find_pma_entry
    hash 260fc7e3
    11: read memory@0x80002e88(2147495560): 0xa7b0231e47b783(47199985989040003)
  end fetch_insn
  begin sd
    hash 260fc7e3
    12: read x@0x78(120): 0x40008000(1073774592)
    hash 260fc7e3
    13: read x@0x50(80): 0x101000000000020(72339069014638624)
    begin translate_virtual_address
      hash 260fc7e3
      14: read iflags.PRV@0x1d0(464): 0x18(24)
      hash 260fc7e3
      15: read mstatus@0x130(304): 0xa00001800(42949679104)
    end translate_virtual_address
    begin find_pma_entry
      hash 260fc7e3
      16: read pma.istart@0x800(2048): 0x800000f9(2147483897)
      hash 260fc7e3
      17: read pma.ilength@0x808(2056): 0x4000000(67108864)
      hash 260fc7e3
      18: read pma.istart@0x810(2064): 0x1069(4201)
      hash 260fc7e3
      19: read pma.ilength@0x818(2072): 0xf000(61440)
      hash 260fc7e3
      20: read pma.istart@0x820(2080): 0x80000000000002d9(9223372036854776537)
      hash 260fc7e3
      21: read pma.ilength@0x828(2088): 0x3c00000(62914560)
      hash 260fc7e3
      22: read pma.istart@0x830(2096): 0x4000841a(1073775642)
      hash 260fc7e3
      23: read pma.ilength@0x838(2104): 0x1000(4096)
    end find_pma_entry
    hash 260fc7e3
    24: write htif.tohost@0x40008000(1073774592): 0x10100000000000a(72339069014638602) -> 0x101000000000020(72339069014638624)
    hash a5895405
    25: write htif.fromhost@0x40008008(1073774600): 0x0(0) -> 0x101000000000000(72339069014638592)
    hash 8ae8f8f7
    26: write pc@0x100(256): 0x80002e8c(2147495564) -> 0x80002e90(2147495568)
  end sd
  hash d83ff6f5
  27: read minstret@0x128(296): 0xaa218(696856)
  hash d83ff6f5
  28: write minstret@0x128(296): 0xaa218(696856) -> 0xaa219(696857)
  hash 02f2bc90
  29: read mcycle@0x120(288): 0xaa219(696857)
  hash 02f2bc90
  30: write mcycle@0x120(288): 0xaa219(696857) -> 0xaa21a(696858)
end step
```
Understanding these logs in detail requires a deep knowledge of not only RISC-V architecture, but also how Cartesi's emulator implements it.
The material is beyond the scope of this document.
In this particular example, however, was hand-picked for illustration purposes.
The RISC-V instruction being executed, `sd`, writes the 64-bit word `0x0101000000000020` to address `0x40008000` (access&nbsp;#24).
This is the memory-mapped address of HTIF's `tohost` CSR.
The value refers to the console subdevice (`DEV=1`) , command `putchar` (`CMD=1`), and causes the device to output a white-space character (`DATA=0x20`).
I.e., the instruction is drawing the `        \ /   MACHINE` row of the splash screen.

The command-line option `--json-log=<filename>` outputs a machine-readable version of the step log *for each cycle* executed by the emulator.
It is used by internal integration tests that verify the consistency between the Cartesi Machine as implemented by the off-chain emulator and as implemented by the on-chain step verification function.

The command-line optino `--dump-pmas` causes the emulator to dump the contents of all mapped spans in the address space to files.
Each span produces a file `<start>--<length>.bin`.
This is useful to insped the entire state of the machine from outside the emulator.

The final command-line option, `--dump-machine-config` will be explained under the Lua interface to Cartesi Machines.

---
title: Command-line interface
---

In the simplest usage scenario, the `cartesi-machine` command-line utility can be used to define a Cartesi Machine and run it until it halts.
The command-line utility, however, is very versatile.
It was designed to simplify the most common prototyping tasks.

## Initialization

<a name="first-cartesi-machine-example"></a>

The following command instructs `cartesi-machine` to build a Cartesi Machine with `rom.bin` as the [ROM image](machine/ROM.md), and to append the string `quiet` to the automatically generated kernel command line.
The machine has 64MiB of RAM, uses `linux.bin` as the [RAM image](machine/kernel.md), and uses `rootfs.ext2` as the [root file-system](machine/rootfs.md).
(The `rom.bin`, `linux.bin`, and `rootfs.ext2` files are generated by the Emulator SDK.)
Once initialization is complete, the machine executes the command `/bin/ls /bin` and exits.

```bash
playground:~$ cartesi-machine \
    --rom-image="/opt/cartesi/share/images/rom.bin" \
    --append-rom-bootargs="quiet" \
    --ram-length=64Mi \
    --ram-image="/opt/cartesi/share/images/linux.bin" \
    --flash-drive="label:root,filename:/opt/cartesi/share/images/rootfs.ext2"
    -- /bin/ls /bin
```
The `--rom-image`, `--ram-image`, `--ram-length`, and `--flash-drive` command-line options have as default values the same values in the example, so they can be omitted.
To remove these default settings, use the command-line options `--no-ram-image` and `--no-root-flash-drive`, respectively.
(The machine needs a ROM image, and you can simply specify a different one than
the default.)

```bash
playground:~$ cartesi-machine --append-rom-bootargs="quiet" -- /bin/ls /bin
```
The output is
```
Building machine: please wait

         .
        / \
      /    \
\---/---\  /----\
 \       X       \
  \----/  \---/---\
       \    / CARTESI
        \ /   MACHINE
         '

arch           dmesg          linux32        netstat        setserial
ash            dnsdomainname  linux64        nice           sh
base64         dumpkmap       ln             nuke           sleep
busybox        echo           login          pidof          stty
cat            egrep          ls             ping           su
chattr         false          lsattr         pipe_progress  sync
chgrp          fdflush        lsblk          printenv       tar
chmod          fgrep          mk_cmds        ps             touch
chown          findmnt        mkdir          pwd            true
compile_et     getopt         mknod          resume         umount
cp             grep           mktemp         rm             uname
cpio           gunzip         more           rmdir          usleep
cttyhack       gzip           mount          run-parts      vi
date           hostname       mountpoint     sed            watch
dd             kill           mt             setarch        wdctl
df             link           mv             setpriv        zcat
[    0.055690] reboot: Power down

Halted with payload: 0
Cycles: 60547848
```
The output shows the Cartesi Machine splash screen, followed by the listing of directory `/bin`.
The `quiet` option in ROM `bootargs` instructs the Linux kernel to omit a variety of diagnostic messages that would otherwise clutter the output.
The listing was produced by the command that follows `--` separator in the command line.
The Linux kernel passes this unmodified to `/sbin/init`, and the Cartesi-provided `/sbin/init` script executes the command before gracefully halting the machine.

## Interactive sessions

By default, the `cartesi-machine` utility executes the Cartesi Machine non-interactive mode.
Verifiable computations must always be run in non-interactive sessions.
User interaction with a Cartesi Machine via the console is, after all, not reproducible.
Nevertheless, during development, it is often convenient to directly interact with the emulator, as if using a computer console.

The command-line option `-i` (short for `--htif-console-getchar`) instructs the emulator to monitor the console for input, and to make this input available to the Linux kernel.
Typically, this option will be used in conjunction with the `--` separator and the command `/bin/sh`, causing the Cartesi-provided `/sbin/init` script to drop into an interactive shell.
Interaction with the shell enables the exploration of the embedded Linux distribution from the inside.
Exiting the shell returns control back to `/sbin/init`, which then gracefully halts the machine.

For example, if an interactive session is started with the following command
```bash
playground:~$ cartesi-machine \
    --append-rom-bootargs="quiet" \
    -i -- /bin/sh
```
it drops into the shell.
Running the command `ls /bin` causes the listing of directory `/bin` to appear.
The command `exit` causes the shell to exit.
The output is
```
Building machine: please wait
Running in interactive mode!

         .
        / \
      /    \
\---/---\  /----\
 \       X       \
  \----/  \---/---\
       \    / CARTESI
        \ /   MACHINE
         '

~ # ls /bin
arch           dnsdomainname  linux64        nice           sh
ash            dumpkmap       ln             nuke           sleep
base64         echo           login          pidof          stty
busybox        egrep          ls             ping           su
cat            false          lsattr         pipe_progress  sync
chattr         fdflush        lsblk          printenv       tar
chgrp          fgrep          mk_cmds        ps             touch
chmod          findmnt        mkdir          pwd            true
chown          getopt         mknod          resume         umount
compile_et     grep           mktemp         rm             uname
cp             gunzip         more           rmdir          usleep
cpio           gzip           mount          run-parts      vi
date           hostname       mountpoint     sed            watch
dd             kill           mt             setarch        wdctl
df             link           mv             setpriv        zcat
dmesg          linux32        netstat        setserial
~ # exit
[  339.117447] reboot: Power down

Halted with payload: 0
Cycles: 339122301929
```
Note that the final cycle count is meaningless, as the machine repeatedly skips cycles forward when idle from one CLINT-generated interrupt to the next (CLINT stands for Core Local Interruptor, the timer device).

## Flash drives

The command-line option `--flash-drive=label:<label>,filename:<filename>` can be used to add between 1 and 8 flash drives to the Cartesi Machine.
Here, the string `<label>` is the *label* for the flash drive, and `<filename>` points to an *image file* with the initial contents of the flash drive.
When the image file contains a valid file-system, the Cartesi-provided `/sbin/init` script will automatically mount this file-system at `/mnt/<label>`.

To enable transparency, Cartesi Machine flash drives are mapped into the machine's 64-bit address space.
Their start and length are set, respectively by the `start:<number>` and `length:<number>` parameters to `--flash-drive`.

By default, the start of the first flash drive (which typically holds the root file-system) is set to the beginning of the second half of the address space (i.e., at offset 2<sup>63</sup>).
Additional flash drives are automatically spaced uniformly within that second half of the address space.
They are therefore separated by 2<sup>60</sup> bytes, which &ldquo;should be enough separation for everyone&rdquo;.
If the start of *any* drive is specified, then the starts for *all* drives must be specified.

The size of a flash drive is automatically set to match the size of its image file.
Because RISC-V uses 4KiB pages, image files must have a size multiple of 4KiB.
(The `truncate` utility can be used to pad a file with zeros so its size is a multiple of 4KiB.)
The machine will fail to build if there is any overlap between the ranges occupied by multiple drives.

For convenience, numbers can be specified in decimal or hexadecimal (e.g., `4096` or `0x1000`) and may include a suffix multiplier (i.e., `Ki` to multiply by 2<sup>10</sup>, `Mi` to multiply by 2<sup>20</sup>, and `Gi` to multiply by 2<sup>30</sup>).
They can also use C's *shift left* notation to multiply by arbitrary powers of 2 (e.g. `1 << 24` meaning 2<sup>24</sup>).

When the `length` of a drive is specified, the `filename` parameter can be omitted.
In that case, the drive starts in a *pristine* state: i.e., filled with zeros.
If, however, both `length` and `filename` are specified, then the `length` must exactly match the size of image file given by the `filename` parameter.

Choosing convenient starts and length for flash drives in the machine's address space has implications on certain operations, discussed in detail under [the blockchain perspective](../blockchain/hash.md), that involve the manipulation of hashes of the Cartesi Machine state.

The preferred file-system type is `ext2`.
These file-systems can be easily created with the `genext2fs` command-line utility (available in Ubuntu as its own package), and inspected or modified with the `e2ls`, `e2cp` command-line utilities (available in Ubuntu as the `e2tools` package). <a name="cartesi-machine-with-foo-flash-drive"></a>

<a name="cartesi-machine-with-foo-flash-drive"></a>

For example,
```bash
playground:~$ mkdir foo
playground:~$ echo Hello world > foo/bar.txt
playground:~$ genext2fs -b 1024 -d foo foo.ext2
playground:~$ cartesi-machine \
    --append-rom-bootargs="quiet" \
    --flash-drive="label:foo,filename:foo.ext2" \
    -- "/bin/cat /mnt/foo/bar.txt"
```
Here, a flash drive with label `foo` is initialized with the contents of an `ext2` file-system in the image file `foo.ext2`.

:::note
The `genext2fs` command produces a file-system that includes modification times (and user IDs, permissions etc).
Therefore, the `genext2fs` command is *not* reproducible, in the sense that each time it is executed, it may produce a different `./foo.ext2` file.
However, files generated once can be safely distributed.
:::

The Cartesi-provided `/sbin/init` mounts this as `/mnt/foo`.
The command executed in the machine simply copies the contents of `/mnt/foo/bar` to the terminal.
The output is
```
Building machine: please wait

         .
        / \
      /    \
\---/---\  /----\
 \       X       \
  \----/  \---/---\
       \    / CARTESI
        \ /   MACHINE
         '

Hello world
[    0.058916] reboot: Power down

Halted with payload: 0
Cycles: 63942682
```

## Persistent flash drives

The emulator never modifies the ROM and RAM image files.
They are simply loaded into host memory and only this copy is exposed to changes caused by code executing in the target.
(The `--dump-pmas` command-line option can be used to inspect the modified copies for debugging purposes. See below.)

By default, the emulator also does *not* modify the image files for any of the flash drives.
However, since these image files can be very large, the emulator does not pre-allocate any host memory for flash drives.
Instead, it uses the operating system's memory mapping capabilities.
The operating system reads to host memory only those pages from the image file that are actually read by code executing in the target.
(Naturally, when a state hash is requested, all image files are read from disk in their entirety and processed. See below.)
These image files are mapped to host memory in a *copy-on-write* fashion.
When code running in the target causes the emulator to write to a mapped image file, the operating system makes a copy of the page before modification and replaces the mapping to point to the fresh copy.
The image files are never written to.
For example, running the machine
```bash
playground:~$ cartesi-machine \
    --append-rom-bootargs="quiet" \
    --flash-drive="label:foo,filename:foo.ext2" \
    -- "/bin/ls /mnt/foo/*.txt && /bin/cp /mnt/foo/bar.txt /mnt/foo/baz.txt && ls /mnt/foo/*.txt"
```
produces the output
```
Building machine: please wait

         .
        / \
      /    \
\---/---\  /----\
 \       X       \
  \----/  \---/---\
       \    / CARTESI
        \ /   MACHINE
         '

/mnt/foo/bar.txt
/mnt/foo/bar.txt  /mnt/foo/baz.txt
[    0.060786] reboot: Power down

Halted with payload: 0
Cycles: 65823435
```
indicating that the file-system was modified, at least from the perspective of the target.
However, inspecting the `foo.ext2` image file from outside the emulator shows it is unchanged.
```
playground:~$ e2ls -al foo.ext2:*.txt
     12  100644   501    20       13 19-May-2020 14:48 bar.txt
```

This behavior is appropriate when the flash drives will only be used as inputs.
For output flash drives, target changes to flash drives must reflect on the corresponding image files.
To that end, the parameter `shared` can be passed to command-line option `--flash-drive`, causing the imaged files to be mapped to host memory in a *shared* fashion.
For example,
```bash
playground:~$ cartesi-machine \
    --append-rom-bootargs="quiet" \
    --flash-drive="label:foo,filename:foo.ext2,shared" \
    -- "/bin/ls /mnt/foo/*.txt && /bin/cp /mnt/foo/bar.txt /mnt/foo/baz.txt && ls /mnt/foo/*.txt"
```
produces exactly the same output as before.
However, the backing file `foo.ext2` has indeed been modified.
```
playground:~$ e2ls -al foo.ext2:*.txt
     12  100644   501    20       13 19-May-2020 14:48 bar.txt
     13  100644     0     0       13 31-Dec-1969 21:00 baz.txt
```

## Limiting execution

Before returning control to the command line, `cartesi-machine` prints the value of *halt payload* and the number of *cycles*.
Halt payloads are used only for regression tests.
When the `poweroff` command available inside `rootfs.ext2` is invoked by `/sbin/init` during a graceful shutdown, the payload will be zero.

Typically, the `cartesi-machine` utility only returns when the Cartesi Machine halts.  For example, running
```bash
playground:~$ cartesi-machine \
    --append-rom-bootargs="quiet"
```
produces the output
```
Building machine: please wait

         .
        / \
      /    \
\---/---\  /----\
 \       X       \
  \----/  \---/---\
       \    / CARTESI
        \ /   MACHINE
         '

Nothing to do.
[    0.051769] reboot: Power down

Halted with payload: 0
Cycles: 56623562
```
Here, the Cartesi-provided `/sbin/init` simply reports there is nothing to do nothing to do before halting gracefully.
This takes over 56M cycles to complete, mostly spent initializing up the Linux kernel.

The machine's processor includes a control and status register (CSR), named `mcycle`, that starts at 0 and is incremented after every cycle.
The maximum cycle can be specified with the command-line option `--max-mcycle=<number>`.
For example, adding the `--max-mcycle=695931` command-line option
```bash
playground:~$ cartesi-machine \
    --append-rom-bootargs="quiet" \
    --max-mcycle=695931
```
produces the output
```
Building machine: please wait

         .
        / \
      /    \
\---/---\  /----\
 \       X       \
  \----/  \---/---\
       \    / CARTESI
Cycles: 695931
```
Note the execution was interrupted before the splash screen was completed.

The ability to limit computation to an arbitrary number of cycles is fundamental to the verifiability of Cartesi Machines, as is explained in detail under the [the blockchain perspective](#the-blockchain-perspective).

## Progress feedback

A target application can inform the host of its progress by using a Cartesi-specific `/dev/yield` Linux device.
Within the target, the Linux device can be controlled in the command-line with the utility `/opt/cartesi/bin/yield`, pre-installed in the root file-system `rootfs.ext2`.
The progress feedback is accessed with the `--progress=<permil>` command-line option.

For example, during the execution of the loop,
```bash
playground:~$ cartesi-machine \
    --append-rom-bootargs="quiet" \
    --htif-yield-progress \
    -- "/bin/ash -c 'for i in \$(seq 0 5 1000); do /opt/cartesi/bin/yield --progress=\$i; done'"
```
the `cartesi-machine` utility receives control back from the emulator every time the target executes the `yield` utility.
(If the `--htif-yield-progress` command-line option to `cartesi-machine` is omitted, the emulator essentially ignores yield requests from the target.)
Each time `cartesi-machine` receives control due to a yield, it prints a progress message (shown at 44% below) and resumes the emulator so it can continue working.
```
Building machine: please wait

         .
        / \
      /    \
\---/---\  /----\
 \       X       \
  \----/  \---/---\
       \    / CARTESI
        \ /   MACHINE
         '

Progress:  44.00
```
This feature is most useful when the emulator is controlled programmatically, via its Lua, C++, or gRPC interfaces, where Cartesi Machines typically run disconnected from the console.
In these situations, the progress device can be used to drive a dynamic user interface element that reassures users progress is being made during long, silent computations.
Its handling by `cartesi-machine`, which does have access to the console, is simply to help with prototyping and debugging.

The protocols followed by the `/opt/cartesi/bin/yield` utility to interact with the `/dev/yield` driver and by the driver itself to communicate with the HTIF device are explained in detail under the [target perspective](../target/linux.md#yield-device).

:::danger Editor note
Waiting for the new kernel device and the new command-line utility so we can run this example as written.
Current output is for the old version that runs `/opt/cartesi/bin/htif --yield 0 $i` instead.
:::

## State hashes

:::danger Editor note
We need to regenerate these hash values once we have settled on a release for `rom.bin`, `linux.bin`, and `rootfs.bin`.
Otherwise readers will be confused.
:::

The `cartesi-machine` utility can also be used to output Cartesi Machine state hashes.
State hashes are Merkle tree root hashes of the entire 64-bit address space of the Cartesi Machine, where the leaves are aligned 64-bit words.
Since Cartesi Machines are transparent, the contents of this address space encompass the entire machine state, including all processor CSRs and general-purpose registers, the contents of RAM and ROM, of all flash drives, and of all other devices connected to the board.
State hashes therefore work as cryptographic signatures of the machine, and implicitly of the computation they are about to execute.

To obtain the state hash right before execution starts, use the command-line option `--initial-hash`.
Conversely, to obtain the state hash right after execution is done, use the option `--final-hash`.
For example,
```bash
playground:~$ cartesi-machine \
    --append-rom-bootargs="quiet" \
    --max-mcycle=695931 \
    --initial-hash \
    --final-hash
```
produces the output
```
Building machine: please wait
0: 8e4f7aa0d4a753f16d8430f30ca127b9ed87256f99b9276e29532d50d220c8c0

         .
        / \
      /    \
\---/---\  /----\
 \       X       \
  \----/  \---/---\
       \    / CARTESI
Cycles: 695931
695931: 841eaf0e73aa6af6d18d93ebe3c5202604a3af33b512c9752a879dc65142312d
```
The initial state hash `8e4f7aa0...` is the Merkle tree root hash for the initial Cartesi Machine state.
Since Cartesi Machines are reproducible, the initial state hash also works as a *future* on the entire the computation itself.
In other words, the &ldquo;final state hash&rdquo; `841eaf0e...` is the &ldquo;only&rdquo; possible outcome for the `--final-hash` at cycle 695931, given the result of the `--initial-hash` operation was `8e4f7aa0...`.

:::info
The quotes around &ldquo;only&rdquo; are pedantic.
It is true that there are a multitude of machine states that produce the same state hash.
After all, the Keccak-256 state hashes fit in 256-bits, whereas machine states can take gigabytes.
There are therefore many more possible machine states than possible state hashes.
By the pigeonhole principle, there must be multiple machines with the same hash (i.e., hash collisions).
However, given only the state hash, finding a Cartesi Machine with that state hash should be virtually impossible.
Given a Cartesi Machine and its state hash, finding a *second* Cartesi Machine with the same state hash should also be virtually impossible.
Even finding two different Cartesi Machines that have the same state hash (any hash) should be virtually impossible.
Cryptographic hash functions, such as Keccak-256, were designed *specifically* to have these properties.
:::

Allowing the machine to run until it halts
```bash
playground:~$ cartesi-machine \
    --append-rom-bootargs="quiet" \
    --initial-hash \
    --final-hash
```
produces instead the output
```
Building machine: please wait
0: 8e4f7aa0d4a753f16d8430f30ca127b9ed87256f99b9276e29532d50d220c8c0

         .
        / \
      /    \
\---/---\  /----\
 \       X       \
  \----/  \---/---\
       \    / CARTESI
        \ /   MACHINE
         '

Nothing to do.
[    0.051769] reboot: Power down

Halted with payload: 0
Cycles: 56623562
56623562: d418e364fd29238c26dab1e9315b1c18469c764f57828bc4c01c376de39045e3
```
Naturally, the initial state hash is the same as before.
However, the final state hash `d418e364...` now pertains to cycle 56623562, where the machine is halted.
This is the &ldquo;only&rdquo; possible state hash for a *halted* machine that started from state hash `8e4f7aa0...`.

## Persistent Cartesi Machines

At any point in their execution, Cartesi Machines can be stored to disk.
A stored machine can later be loaded to continue its execution from where it left off.
To store a machine to a given `<directory>`, use the command-line option `--store=<directory>`.
The machine is stored in the state it was before `cartesi-machine` returns to the command line.
For example, to store the machine corresponding to state hash `841eaf0e...`
```bash
playground:~$ cartesi-machine \
    --append-rom-bootargs="quiet" \
    --max-mcycle=695931 \
    --store="machine-841eaf0e"
```
This command creates a directory `machine-841eaf0e/`, containing a variety of files that allow the Cartesi Machine emulator to recreate a machine state.
Every image file is copied into the directory, so there are no external dependencies.

:::note
If the machine initialization involved large image files or a considerable amount of RAM, this operation may consume significant disk space.
It will also take the time required by the copying of image files into the directory, and by the computation of the state hash.
:::

If the directory already exists, the operation will fail.
This prevents the overwriting of a Cartesi Machine by mistake.
Once created, the directory can be compressed and transferred to other hosts.
To restore the corresponding Cartesi Machine, use the command-line option `--load=<directory>`.
For example,
```bash
playground:~$ cartesi-machine \
    --load="machine-841eaf0e" \
    --initial-hash \
    --final-hash
```
produces the output
```
Loading machine: please wait
695931: 841eaf0e73aa6af6d18d93ebe3c5202604a3af33b512c9752a879dc65142312d

        \ /   MACHINE
         '

Nothing to do.
[    0.051769] reboot: Power down

Halted with payload: 0
Cycles: 56623562
56623562: d418e364fd29238c26dab1e9315b1c18469c764f57828bc4c01c376de39045e3
```
Note that, other than `--load`, no initialization command-line options were used.
These initializations were used to define the machine before it was stored: their values are implicitly encoded in the stored state.
Note also that the initial state hash `841eaf0e...` after `--load` matches the final state hash before `--store`.
After all, they are state hashes concerning the state of the same machine at the same cycle.
In fact, `--store` writes this state hash inside the directory, and `--load` verifies that the state hash of the restored machine matches what it found in the directory.
Finally, note that the machine continues from where it left off, and reaches the same final state hash `d418e364...`, as if it had never been interrupted.

## Cartesi Machine templates

*Templates* are one of the key uses for Cartesi Machines stored to disk.
Cartesi Machine templates are machines in which the contents of one or more flash drives are still unknown.
To put it another way, Cartesi Machine templates behave like functions on the yet-to-be-defined contents of their flash drive parameters.

As discussed in detail under [the blockchain perspective](../blockchain/hash.md), starting from template hashes and the hashes of the flash drives, it is possible to obtain the state hash of the *instantiated template*&mdash;the state hash for a Cartesi Machine with drives replaced by their actual content.
This is how a smart contract can specify a computation to be performed off-chain over arbitrary input.
Starting from the template hash, and in possession of the flash drive hashes, it instantiates the template, generating the initial state hash for the corresponding Cartesi Machine.

For example, it is possible to create a Cartesi Machine that operates as an arbitrary-precision arithmetic expression evaluator.
The machine takes the expression in text, inside a raw input flash drive labelled `input`, and copies the output into a raw output flash drive, labelled `output` (`shared`, of course, so the output persists after the emulator is done).
The `bc` command-line utility, available in all Linux distributions, is the perfect tool for this job.
The command passed to `cartesi-machine` will read the contents of the input flash drive using the `dd` command-line utility, extract a zero-terminated string from it using a tiny Lua script run by the `lua` interpreter, pipe the result to `bc`, and finally use `dd` again to write its results to the output flash drive.
Here is the sample playground session
```bash
playground:~$ \rm -f output.raw
playground:~$ truncate -s 4K output.raw
playground:~$ echo "6*2^1024 + 3*2^512" > input.raw
playground:~$ truncate -s 4K input.raw
playground:~$ cartesi-machine \
    --append-rom-bootargs="quiet" \
    --flash-drive="label:input,length:1<<12,filename:input.raw" \
    --flash-drive="label:output,length:1<<12,filename:output.raw,shared" \
    -- "dd status=none if=/dev/mtdblock1 | lua -e 'print((string.unpack(\"z\", io.read(\"*a\"))))' | bc | dd status=none of=/dev/mtdblock2"
playground:~$ luapp5.3 -e 'print((string.unpack("z", io.read("*a"))))' < output.raw
```

:::danger Editor note
We should change this example to use the `flashdrive` utility.
It would look something like

```
"dd status=none if=\$(flashdrive input) | lua -e 'print((string.unpack(\"z\", io.read(\"a\"))))' | bc | dd status=none of=\$(flashdrive output)"`
```

Also remove the `*` because Lua 5.3 does not use it anymore.
This will obviously change the hashes.
:::

Using the `truncate` command-line utility, the session creates a 4KiB file `output.raw` containing only zeros to serve as the output drive image.
Then, it creates the `input.raw` file for use as the input drive image containing the expression `6*2^1024 + 3*2^512\n` to be evaluated.
This file is then padded with zeros to 4KiB in size.
The session then invokes the `cartesi-machine` command-line utility to evaluate the expression.
The output of the `cartesi-machine` command is
```
Building machine: please wait

         .
        / \
      /    \
\---/---\  /----\
 \       X       \
  \----/  \---/---\
       \    / CARTESI
        \ /   MACHINE
         '

[    0.062694] reboot: Power down

Halted with payload: 0
Cycles: 67911528
```
Once the emulator returns, the session uses a tiny Lua script, run by the playground's `luapp5.3` Lua interpreter, to print the contents of the output drive, which reads
```
10786158809173895446375831144734148401707861873653839436405804869463\
96054833005778796250863934445216126720683279228360145952738612886499\
73495708458383684478649003115037698421037988831222501494715481595948\
96901677837132352593468675094844090688678579236903861342030923488978\
36036892526733668721977278692363075584
```
This is indeed the result of 6&times;2<sup>1024</sup>+3&times;2<sup>512</sup>.

To create the template, simply omit the input and output image filenames.
This will cause the drives to be filled with zeros.
Then, limit the computation with `--max-mcycle=0`, to prevent the Cartesi Machine from running.
Finally, use the `--store="calculator-template"` command-line option to store the Cartesi Machine template.
The `--initial-hash` command-line option prints the resulting template hash.
```
playground:~$ cartesi-machine \
    --append-rom-bootargs="quiet" \
    --flash-drive="label:input,length:1<<12" \
    --flash-drive="label:output,length:1<<12" \
    --max-mcycle=0 \
    --initial-hash \
    --store="calculator-template" \
    -- "dd status=none if=/dev/mtdblock1 | lua -e 'print((string.unpack(\"z\", io.read(\"*a\"))))' | bc | dd status=none of=/dev/mtdblock2"
```
The result is as follows
```
Building machine: please wait
0: fd9bf57a285b13fe64f9af7a2c69c649c3288b4a682eff126ae1d54ced73e53f

Cycles: 0
Storing machine: please wait
```
The directory `calculator-template/` now contains the Cartesi Machine template.
Although the template cannot be used by the `cartesi-machine` command-line utility (It does not know how to replace flash drives!), it can be used by programs controlling the emulator with the C++, Lua, or gRPC interfaces.
This is how templates are created for use with the Descartes SDK.

## State value proofs

The `cartesi-machine` command-line utility can generate proofs concerning the contents of the machine state.
To generate a proof concerning the state as it is before the machine starts running, use the `--initial-proof=address:<number>,log2_size:<number>[,filename=<filename>]` option.
For proofs concerning the state after the emulator is done, use `--final-proof` instead.
In either case, the filename field is optional.
When provided, the proof will be written to the corresponding file.
Otherwise, the contents will be displayed on screen.

*State value proofs* are proofs that a given node in the Merkle tree of the Cartesi Machine state has a given hash.
Each Merkle tree node covers a contiguous range of the machine's 64-bit address space.
The size of a range is always a power of 2 (given by the `<log2_size>` parameter).
Since the leaves have size 8 (for 64-bits), the valid values for `<log2_size>` are 3&hellip;64.
The range corresponding to each node starts at an `<address>` that is a multiple of its size.

For example, to generate a proof that the Cartesi Machine template above indeed contains a pristine input drive, use the command line
```bash
playground:~$ cartesi-machine \
    --append-rom-bootargs="quiet" \
    --flash-drive="label:input,length:1<<12" \
    --flash-drive="label:output,length:1<<12" \
    --max-mcycle=0 \
    --initial-hash \
    --initial-proof="address:0x9000000000000000,log2_size:12,filename:pristine-input-proof" \
    -- "dd status=none if=/dev/mtdblock1 | lua -e 'print((string.unpack(\"z\", io.read(\"*a\"))))' | bc | dd status=none of=/dev/mtdblock2"
```
Recall the first flash drive, the one with the `rootfs.ext2` image file, is present by default, and is automatically placed at starting address `0x8000000000000000`.
The input flash drive is the therefore the second drive.
It is automatically spaced by 2<sup>60</sup> bytes relative to the first drive, starting at address `0x9000000000000000`.

The output of the command is
```
Building machine: please wait
0: fd9bf57a285b13fe64f9af7a2c69c649c3288b4a682eff126ae1d54ced73e53f

Cycles: 0
```

In addition, the `pristine-input-proof` file now contains a JSON structure with the requested proof
```js title="pristine-input-proof"
{
  "address": 10376293541461622784,
  "log2_size": 12,
  "target_hash": "d8b96e5b7f6f459e9cb6a2f41bf276c7b85c10cd4662c04cbbb365434726c0a0",
  "sibling_hashes": [
    "a3fa5940165e45cc6dbbe759a2b72f66df2e85b72ebc86ced3d7d1e321f0df5b",
    "785b01e980fc82c7e3532ce81876b778dd9f1ceeba4478e86411fb6fdd790683",
    "41187451383460762c06d1c8a72b9cd718866ad4b689e10c9a8c38fe5ef045bd",
    "c30604945ae77a7b78be6669f22f8585e4fb786156e768c7bdbb61f36bab6de7",
    "6d4fe42ea8d1a120c03cf9c50622c2afe4acb0dad98fd62d07ab4e828a94495f",
    "ced9a87b2a6a87e70bf251bb5075ab222138288164b2eda727515ea7de12e249",
    "909efab43c42c0cb00695fc7f1ffe67c75ca894c3c51e1e5e731360199e600f6",
    "414217a618ccb14caa9e92e8c61673afc9583662e812adba1f87a9c68202d60e",
    "fa6a452470f8d645bebfad9779594fc0784bb764a22e3a8181d93db7bf97893c",
    "27a31085634b6ec78864b6d8201c7e93903d75815067e378289a3d072ae172da",
    "f75c40174a91f9ae6b8647854a156029f0b88b83316663ce574a4978277bb6bb",
    "06cc0a6fd12230ea586dae83019fb9e06034ed2803c98d554b93c9a52348caff",
    "712e55805248b92e8677d90f6d284d1d6ffaff2c430657042a0e82624fa3717b",
    "214947127506073e44d5408ba166c512a0b86805d07f5a44d3c41706be2bc15e",
    "7bdd613713ada493cc17efd313206380e6a685b8198475bbd021c6e9d94daab2",
    "5ea69e2f7c7d2ccc85b7e654c07e96f0636ae4044fe0e38590b431795ad0f864",
    "c61ce68b20307a1a81f71ca645b568fcd319ccbb5f651e87b707d37c39e15f94",
    "76e1424883a45ec49d497ddaf808a5521ca74a999ab0b3c7aa9c80f85e93977e",
    "91b4feecbe1789717021a158ace5d06744b40f551076b67cd63af60007f8c998",
    "455306d01081bc3384f82c5fb2aacaa19d89cdfa46cc916eac61121475ba2e61",
    "a1611f1b276b26530f58d7247df459ce1f86db1d734f6f811932f042cee45d0e",
    "29927c21dd71e3f656826de5451c5da375aadecbd59d5ebf3a31fae65ac1b316",
    "5d8b6aa5934f817252c028c90f56d413b9d5d10d89790707dae2fabb249f6499",
    "8dff81e014ce25f2d132497923e267363963cdf4302c5049d63131dc03fd95f6",
    "bec80f4f5d1daa251988826cef375c81c36bf457e09687056f924677cb0bccf9",
    "847a230d34dfb71ed56f2965a7f6c72e6aa33c24c303fd67745d632656c5ef90",
    "e63624cbd316a677cad529bbe4e97b9144e4bc06c4afd1de55dd3e1175f90423",
    "a57b9796fdcb2eda87883c2640b072b140b946bfdf6575cacc066fdae04f6951",
    "85d8820921ff5826148b60e6939acd7838e1d7f20562bff8ee4b5ec4a05ad997",
    "1373a814641d6a1dcef97b883fee61bb84fe60a3409340217e629cc7e4dcc93b",
    "d5d218ef5a296dda8ddc355f3f50c3d0b660a51dfa4d98a6a5a33564556cf83c",
    "3abc751df07437834ba5acb32328a396994aebb3c40f759c2d6d7a3cb5377e55",
    "674857e543d1d5b639058dd908186597e366ad5f3d9c7ceaff44d04d1550b8d3",
    "21e2d8fa914e2559bb72bf0ab78c8ab92f00ef0d0d576eccdd486b64138a4172",
    "4fd085aceaa7f542d787ee4196d365f3cc566e7bbcfbfd451230c48d804c017d",
    "3c5126b9c7e33c8e5a5ac9738b8bd31247fb7402054f97b573e8abb9faad219f",
    "fdc242788f654b57a4fb32a71b335ef6ff9a4cc118b282b53bdd6d6192b7a82c",
    "fedc0d0dbbd855c8ead673544899b0960e4a5a7ca43b4ef90afe607de7698cae",
    "766c5e8ac9a88b35b05c34747e6507f6b044ab66180dc76ac1a696de03189593",
    "3e2337b715f6ac9a6a272622fdc2d67fcfe1da3459f8dab4ed7e40a657a54c36",
    "f065ec220c1fd4ba57e341261d55997f85d66d32152526736872693d2b437a23",
    "13e466a8935afff58bb533b3ef5d27fba63ee6b0fd9e67ff20af9d50deee3f8b",
    "27d86025599a41233848702f0cfc0437b445682df51147a632a0a083d2d38b5e",
    "99af665835aabfdc6740c7e2c3791a31c3cdc9f5ab962f681b12fc092816a62f",
    "2b573c267a712a52e1d06421fe276a03efb1889f337201110fdc32a81f8e1524",
    "7a71f6ee264c5d761379b3d7d617ca83677374b49d10aec50505ac087408ca89",
    "f7549f26cc70ed5e18baeb6c81bb0625cb95bb4019aeecd40774ee87ae29ec51",
    "2122e31e4bbd2b7c783d79cc30f60c6238651da7f0726f767d22747264fdb046",
    "91e3eee5ca7a3da2b3053c9770db73599fb149f620e3facef95e947c0ee860b7",
    "63e8806fa0d4b197a259e8c3ac28864268159d0ac85f8581ca28fa7d2c0c03eb",
    "c9695393027fb106a8153109ac516288a88b28a93817899460d6310b71cf1e61",
    "d8b96e5b7f6f459e9cb6a2f41bf276c7b85c10cd4662c04cbbb365434726c0a0"
  ],
  "root_hash": "fd9bf57a285b13fe64f9af7a2c69c649c3288b4a682eff126ae1d54ced73e53f"
}
```
The `root_hash` value `fd9bf57a...` is the expected initial state hash seen in the output of the `cartesi-machine` command.
The `address` value `10376293541461622784` is the same as `0x9000000000000000` in decimal.
The `log2_size` value `12` field refers to the size of the 4KiB input drive.
The `target_hash` value `d8b96e5b7...` in the proof gives the hash of the input drive.

The hash of the input drive can be also computed externally with the `cartesi-machine-hash` command-line utility.
The utility produces the hash of any file with a power-of-two size.
The `--tree-log2-size=<log2_size>` option specifies the size.
If an input file is smaller than the specified size, the utility assumes the missing data is composed entirely of bytes 0.
The utility deals efficiently with zero paddings of any size because pristine hashes for all power-of-two-sizes can be precomputed.
For example, to quickly generate the hash for a pristine input with 4KiB size, run
```bash
playground:~$ head -c 0 | cartesi-machine-hash --tree-log2-size=12 
d8b96e5b7f6f459e9cb6a2f41bf276c7b85c10cd4662c04cbbb365434726c0a0
```
Indeed, the hash values match. 

The `sibling_hashes` array contains the hashes of the siblings to all nodes in the path from the root all the way down to the target node (excluding the root, which has no sibling).
Using the `address` field, the `target_hash` hash, and the `sibling_hashes` array, it is possible to go up the tree computing the hashes along the path, until the root hash is produced.
If the root hash obtained by this process matches the expected root hash, the proof is valid.
Otherwise, something is amiss.
(Incidentally, from the hash of its sibling, the last entry in `sibling_hashes`, it is possible to ascertain that the neighboring range to the input drive also contains 4KiB of bytes 0.)

To compute the hash for the desired `input.raw` file with contents `6*2^1024 + 3*2^512\n`, padded with zeros, run
```bash
playground:~$ echo "6*2^1024 + 3*2^512" | cartesi-machine-hash --tree-log2-size=12
2c92c99754e85e3e2a29edd84228a62b051f9f55a5563f8decc7c6d5d9d8ef64
```

Using a process similar to the proof verification described above, it is possible to go up the Merkle tree for the template using the `sibling_hashes` array in the proof, but starting from the hash `2c92c997...` of the desired `input.raw` image rather than hash `d8b96e5b...` of the template's pristine drive.
The results is the initial state hash for the instantiated template: the same that can be seen in the initial state hash produced by the `cartesi-machine` command-line
```bash
playground:~$ echo "6*2^1024 + 3*2^512" > input.raw
playground:~$ truncate -s 4K input.raw
playground:~$ cartesi-machine \
    --append-rom-bootargs="quiet" \
    --flash-drive="label:input,length:1<<12,filename:input.raw" \
    --flash-drive="label:output,length:1<<12" \
    --initial-hash \
    --initial-proof="address:0x9000000000000000,log2_size:12,filename:input-proof" \
	--max-mcycle=0 \
    "dd status=none if=/dev/mtdblock1 | lua -e 'print((string.unpack(\"z\", io.read(\"*a\"))))' | bc | dd status=none of=/dev/mtdblock2"
```

The contents of the `input-proof` are

```js title="input-proof"
{
  "address": 10376293541461622784,
  "log2_size": 12,
  "target_hash": "2c92c99754e85e3e2a29edd84228a62b051f9f55a5563f8decc7c6d5d9d8ef64",
  "sibling_hashes": [
    "a3fa5940165e45cc6dbbe759a2b72f66df2e85b72ebc86ced3d7d1e321f0df5b",
    "785b01e980fc82c7e3532ce81876b778dd9f1ceeba4478e86411fb6fdd790683",
    "41187451383460762c06d1c8a72b9cd718866ad4b689e10c9a8c38fe5ef045bd",
    "c30604945ae77a7b78be6669f22f8585e4fb786156e768c7bdbb61f36bab6de7",
    "6d4fe42ea8d1a120c03cf9c50622c2afe4acb0dad98fd62d07ab4e828a94495f",
    "ced9a87b2a6a87e70bf251bb5075ab222138288164b2eda727515ea7de12e249",
    "909efab43c42c0cb00695fc7f1ffe67c75ca894c3c51e1e5e731360199e600f6",
    "414217a618ccb14caa9e92e8c61673afc9583662e812adba1f87a9c68202d60e",
    "fa6a452470f8d645bebfad9779594fc0784bb764a22e3a8181d93db7bf97893c",
    "27a31085634b6ec78864b6d8201c7e93903d75815067e378289a3d072ae172da",
    "f75c40174a91f9ae6b8647854a156029f0b88b83316663ce574a4978277bb6bb",
    "06cc0a6fd12230ea586dae83019fb9e06034ed2803c98d554b93c9a52348caff",
    "712e55805248b92e8677d90f6d284d1d6ffaff2c430657042a0e82624fa3717b",
    "214947127506073e44d5408ba166c512a0b86805d07f5a44d3c41706be2bc15e",
    "7bdd613713ada493cc17efd313206380e6a685b8198475bbd021c6e9d94daab2",
    "5ea69e2f7c7d2ccc85b7e654c07e96f0636ae4044fe0e38590b431795ad0f864",
    "c61ce68b20307a1a81f71ca645b568fcd319ccbb5f651e87b707d37c39e15f94",
    "76e1424883a45ec49d497ddaf808a5521ca74a999ab0b3c7aa9c80f85e93977e",
    "91b4feecbe1789717021a158ace5d06744b40f551076b67cd63af60007f8c998",
    "455306d01081bc3384f82c5fb2aacaa19d89cdfa46cc916eac61121475ba2e61",
    "a1611f1b276b26530f58d7247df459ce1f86db1d734f6f811932f042cee45d0e",
    "29927c21dd71e3f656826de5451c5da375aadecbd59d5ebf3a31fae65ac1b316",
    "5d8b6aa5934f817252c028c90f56d413b9d5d10d89790707dae2fabb249f6499",
    "8dff81e014ce25f2d132497923e267363963cdf4302c5049d63131dc03fd95f6",
    "bec80f4f5d1daa251988826cef375c81c36bf457e09687056f924677cb0bccf9",
    "847a230d34dfb71ed56f2965a7f6c72e6aa33c24c303fd67745d632656c5ef90",
    "e63624cbd316a677cad529bbe4e97b9144e4bc06c4afd1de55dd3e1175f90423",
    "a57b9796fdcb2eda87883c2640b072b140b946bfdf6575cacc066fdae04f6951",
    "85d8820921ff5826148b60e6939acd7838e1d7f20562bff8ee4b5ec4a05ad997",
    "1373a814641d6a1dcef97b883fee61bb84fe60a3409340217e629cc7e4dcc93b",
    "d5d218ef5a296dda8ddc355f3f50c3d0b660a51dfa4d98a6a5a33564556cf83c",
    "3abc751df07437834ba5acb32328a396994aebb3c40f759c2d6d7a3cb5377e55",
    "674857e543d1d5b639058dd908186597e366ad5f3d9c7ceaff44d04d1550b8d3",
    "21e2d8fa914e2559bb72bf0ab78c8ab92f00ef0d0d576eccdd486b64138a4172",
    "4fd085aceaa7f542d787ee4196d365f3cc566e7bbcfbfd451230c48d804c017d",
    "3c5126b9c7e33c8e5a5ac9738b8bd31247fb7402054f97b573e8abb9faad219f",
    "fdc242788f654b57a4fb32a71b335ef6ff9a4cc118b282b53bdd6d6192b7a82c",
    "fedc0d0dbbd855c8ead673544899b0960e4a5a7ca43b4ef90afe607de7698cae",
    "766c5e8ac9a88b35b05c34747e6507f6b044ab66180dc76ac1a696de03189593",
    "3e2337b715f6ac9a6a272622fdc2d67fcfe1da3459f8dab4ed7e40a657a54c36",
    "f065ec220c1fd4ba57e341261d55997f85d66d32152526736872693d2b437a23",
    "13e466a8935afff58bb533b3ef5d27fba63ee6b0fd9e67ff20af9d50deee3f8b",
    "27d86025599a41233848702f0cfc0437b445682df51147a632a0a083d2d38b5e",
    "99af665835aabfdc6740c7e2c3791a31c3cdc9f5ab962f681b12fc092816a62f",
    "2b573c267a712a52e1d06421fe276a03efb1889f337201110fdc32a81f8e1524",
    "7a71f6ee264c5d761379b3d7d617ca83677374b49d10aec50505ac087408ca89",
    "f7549f26cc70ed5e18baeb6c81bb0625cb95bb4019aeecd40774ee87ae29ec51",
    "2122e31e4bbd2b7c783d79cc30f60c6238651da7f0726f767d22747264fdb046",
    "91e3eee5ca7a3da2b3053c9770db73599fb149f620e3facef95e947c0ee860b7",
    "63e8806fa0d4b197a259e8c3ac28864268159d0ac85f8581ca28fa7d2c0c03eb",
    "c9695393027fb106a8153109ac516288a88b28a93817899460d6310b71cf1e61",
    "d8b96e5b7f6f459e9cb6a2f41bf276c7b85c10cd4662c04cbbb365434726c0a0"
  ],
  "root_hash": "020b26ea903908b9a51f43e6f6fccdd37e777755bbcdd936b769397ed56bcfdd"
}
```
The `target_hash` value `2c92c997...` reflects the hash computed for the input, whereas `root_hash` value `020b26ea90...` differs from `fd9bf57a...` obtained for template, as expected.
Moreover, the `sibling_hashes` entries in the template Cartesi Machine and in the instantiated Cartesi Machine remain the same, reflecting the fact that there were no other changes in the machine's initial state.

Another useful proof is the one for the *output* drive, once the machine is halted.
To obtain this proof, run 
```bash
playground:~$ \rm -f output.raw
playground:~$ truncate -s 4K output.raw
playground:~$ echo "6*2^1024 + 3*2^512" > input.raw
playground:~$ truncate -s 4K input.raw
playground:~$ cartesi-machine \
    --append-rom-bootargs="quiet" \
    --flash-drive="label:input,length:1<<12,filename:input.raw" \
    --flash-drive="label:output,length:1<<12,filename:output.raw,shared" \
    --final-hash \
    --final-proof="address:0xa000000000000000,log2_size:12,filename:output-proof" \
    -- "dd status=none if=/dev/mtdblock1 | lua -e 'print((string.unpack(\"z\", io.read(\"*a\"))))' | bc | dd status=none of=/dev/mtdblock2"
```

This produces the output

```
Building machine: please wait

         .
        / \
      /    \
\---/---\  /----\
 \       X       \
  \----/  \---/---\
       \    / CARTESI
        \ /   MACHINE
         '

[    0.062695] reboot: Power down

Halted with payload: 0
Cycles: 67912443
67912443: 0578418ba773152848e4b1e40bc3cdfd405401fd4c7e7f12a842c0234e3d9e51
```
The contents of the `output-proof` are
```js title="output-proof"
{
  "address": 11529215046068469760,
  "log2_size": 12,
  "target_hash": "b15a6b8aab8a423c725f9ad55fd46c4481ba91008f3a01593192de37a7a41565",
  "sibling_hashes": [
    "9eed8e881bed0efa65156b0cd34ea70028d8947ead10e019d5396eb2316a3a6a",
    "785b01e980fc82c7e3532ce81876b778dd9f1ceeba4478e86411fb6fdd790683",
    "cf9f855cbc756aa222b23cea3b9180c51375971c15d38be51961950157d20fdb",
    "6d1ab973982c7ccbe6c1fae02788e4422ae22282fa49cbdb04ba54a7a238c6fc",
    "6d4fe42ea8d1a120c03cf9c50622c2afe4acb0dad98fd62d07ab4e828a94495f",
    "ced9a87b2a6a87e70bf251bb5075ab222138288164b2eda727515ea7de12e249",
    "909efab43c42c0cb00695fc7f1ffe67c75ca894c3c51e1e5e731360199e600f6",
    "414217a618ccb14caa9e92e8c61673afc9583662e812adba1f87a9c68202d60e",
    "fa6a452470f8d645bebfad9779594fc0784bb764a22e3a8181d93db7bf97893c",
    "27a31085634b6ec78864b6d8201c7e93903d75815067e378289a3d072ae172da",
    "f75c40174a91f9ae6b8647854a156029f0b88b83316663ce574a4978277bb6bb",
    "06cc0a6fd12230ea586dae83019fb9e06034ed2803c98d554b93c9a52348caff",
    "712e55805248b92e8677d90f6d284d1d6ffaff2c430657042a0e82624fa3717b",
    "214947127506073e44d5408ba166c512a0b86805d07f5a44d3c41706be2bc15e",
    "7bdd613713ada493cc17efd313206380e6a685b8198475bbd021c6e9d94daab2",
    "5ea69e2f7c7d2ccc85b7e654c07e96f0636ae4044fe0e38590b431795ad0f864",
    "c61ce68b20307a1a81f71ca645b568fcd319ccbb5f651e87b707d37c39e15f94",
    "76e1424883a45ec49d497ddaf808a5521ca74a999ab0b3c7aa9c80f85e93977e",
    "91b4feecbe1789717021a158ace5d06744b40f551076b67cd63af60007f8c998",
    "455306d01081bc3384f82c5fb2aacaa19d89cdfa46cc916eac61121475ba2e61",
    "a1611f1b276b26530f58d7247df459ce1f86db1d734f6f811932f042cee45d0e",
    "29927c21dd71e3f656826de5451c5da375aadecbd59d5ebf3a31fae65ac1b316",
    "5d8b6aa5934f817252c028c90f56d413b9d5d10d89790707dae2fabb249f6499",
    "8dff81e014ce25f2d132497923e267363963cdf4302c5049d63131dc03fd95f6",
    "bec80f4f5d1daa251988826cef375c81c36bf457e09687056f924677cb0bccf9",
    "847a230d34dfb71ed56f2965a7f6c72e6aa33c24c303fd67745d632656c5ef90",
    "e63624cbd316a677cad529bbe4e97b9144e4bc06c4afd1de55dd3e1175f90423",
    "a57b9796fdcb2eda87883c2640b072b140b946bfdf6575cacc066fdae04f6951",
    "85d8820921ff5826148b60e6939acd7838e1d7f20562bff8ee4b5ec4a05ad997",
    "1373a814641d6a1dcef97b883fee61bb84fe60a3409340217e629cc7e4dcc93b",
    "d5d218ef5a296dda8ddc355f3f50c3d0b660a51dfa4d98a6a5a33564556cf83c",
    "3abc751df07437834ba5acb32328a396994aebb3c40f759c2d6d7a3cb5377e55",
    "674857e543d1d5b639058dd908186597e366ad5f3d9c7ceaff44d04d1550b8d3",
    "21e2d8fa914e2559bb72bf0ab78c8ab92f00ef0d0d576eccdd486b64138a4172",
    "4fd085aceaa7f542d787ee4196d365f3cc566e7bbcfbfd451230c48d804c017d",
    "3c5126b9c7e33c8e5a5ac9738b8bd31247fb7402054f97b573e8abb9faad219f",
    "fdc242788f654b57a4fb32a71b335ef6ff9a4cc118b282b53bdd6d6192b7a82c",
    "fedc0d0dbbd855c8ead673544899b0960e4a5a7ca43b4ef90afe607de7698cae",
    "766c5e8ac9a88b35b05c34747e6507f6b044ab66180dc76ac1a696de03189593",
    "3e2337b715f6ac9a6a272622fdc2d67fcfe1da3459f8dab4ed7e40a657a54c36",
    "f065ec220c1fd4ba57e341261d55997f85d66d32152526736872693d2b437a23",
    "13e466a8935afff58bb533b3ef5d27fba63ee6b0fd9e67ff20af9d50deee3f8b",
    "27d86025599a41233848702f0cfc0437b445682df51147a632a0a083d2d38b5e",
    "99af665835aabfdc6740c7e2c3791a31c3cdc9f5ab962f681b12fc092816a62f",
    "2b573c267a712a52e1d06421fe276a03efb1889f337201110fdc32a81f8e1524",
    "7a71f6ee264c5d761379b3d7d617ca83677374b49d10aec50505ac087408ca89",
    "f7549f26cc70ed5e18baeb6c81bb0625cb95bb4019aeecd40774ee87ae29ec51",
    "2122e31e4bbd2b7c783d79cc30f60c6238651da7f0726f767d22747264fdb046",
    "91e3eee5ca7a3da2b3053c9770db73599fb149f620e3facef95e947c0ee860b7",
    "63e8806fa0d4b197a259e8c3ac28864268159d0ac85f8581ca28fa7d2c0c03eb",
    "c9695393027fb106a8153109ac516288a88b28a93817899460d6310b71cf1e61",
    "d8b96e5b7f6f459e9cb6a2f41bf276c7b85c10cd4662c04cbbb365434726c0a0"
  ],
  "root_hash": "0578418ba773152848e4b1e40bc3cdfd405401fd4c7e7f12a842c0234e3d9e51"
}
```
Note how the `root_hash` field in the proof matches the final state hash `0578418b...` output by the `cartesi-machine` command-line utility.

To see that the `target_hash` field matches the `output.raw` drive, use the `cartesi-machine-hash` command-line utility:
```bash
cartesi-machine-hash --tree-log2-size=12 < output.raw
b15a6b8aab8a423c725f9ad55fd46c4481ba91008f3a01593192de37a7a41565
```

The `cartesi-machine` command-line utility accepts an arbitrary number of `--initial-proof` and `--final-proof` parameters.
They are computed one-by-one, and either printed or stored in the specified files.

To read more about proofs, go to [the blockchain perspective](../blockchain/hash.md).

## Rarely used options

:::warning
This is an advanced section, not needed by regular users of the Cartesi platform.
:::

The command-line option `--periodic-hashes=<number-period>[,<number-start>]` causes the command-line utility to periodically obtain and print the state hash.
The `<number-period>` argument gives the distance between hashes in cycles. The optional `<number-start>` argument gives the starting cycle for the periodic hashes. (Both `--initial-hash` and `--final-hash` are implied by this option.)

For example, to see the last 10 state hashes from the calculator machine computation, run the command
```bash
playground:~$ \rm -f output.raw
playground:~$ truncate -s 4K output.raw
playground:~$ echo "6*2^1024 + 3*2^512" > input.raw
playground:~$ truncate -s 4K input.raw
playground:~$ cartesi-machine \
    --append-rom-bootargs="quiet" \
    --flash-drive="label:input,length:1<<12,filename:input.raw" \
    --flash-drive="label:output,length:1<<12,filename:output.raw,shared" \
    --periodic-hashes=1,67912433 \
    -- "dd status=none if=/dev/mtdblock1 | lua -e 'print((string.unpack(\"z\", io.read(\"*a\"))))' | bc | dd status=none of=/dev/mtdblock2"
```
The output is

```
0: 020b26ea903908b9a51f43e6f6fccdd37e777755bbcdd936b769397ed56bcfdd

         .
        / \
      /    \
\---/---\  /----\
 \       X       \
  \----/  \---/---\
       \    / CARTESI
        \ /   MACHINE
         '

[    0.062695] reboot: Power down
67912433: 9074fe4d9cd41dc6c818d2b02730b74a2fb13539f0878ccbb88b22c63d0e1908
67912434: e8aa7eaa8a29214e72807d9ab66449549c74479d515e5f69c4e32902eba49663
67912435: c66d390c88bab8699fa75c4f77ae717614af57767df3f27f4c27c38130fb2cd3
67912436: 7e3b5d30faabd9573054d88c24fd2316596b3a5473cfa4a7c7b38962eeb765d5
67912437: 2e3aa5c5febfca14794e4515ab562268e5bde480abee174b7c64182ed0bd566c
67912438: 3739848465eeb5fa75321eafa77f213bd00a4dfec95e437677443bb12596870e
67912439: 5dc29759c379760078ad8f8600f051991ea23bc8e6db33ea1e167414c0568529
67912440: 5ddfccd7201aa89de634752ff421701255c153a4969a8ba6e095967f931d992c
67912441: 649b060ec26de25d3d3951549856e145668804903937dbd859bd40c949c53fd4
67912442: 37b8d4aec3bc3f17f4233927494144039c6171df455b1f5a61450b450cf236bd

Halted with payload: 0
Cycles: 67912443
67912443: 0578418ba773152848e4b1e40bc3cdfd405401fd4c7e7f12a842c0234e3d9e51
```

The command-line option `--dump-pmas` causes the emulator to dump the contents of all mapped spans in the address space to files.
Each span produces a file `<start>--<length>.bin`.
Every other byte in the address space has value 0.
This is useful to inspect the entire state of the machine from outside the emulator.

The command-line option, `--dump-machine-config` will be explained under the [Lua interface](lua.md) to Cartesi Machines.
In a nutshell, it generates the `machine_config` structure that can be used to initialize the exact same Cartesi Machine that the `cartesi-machine` command-line utility will use.

The remaining options in the command-line utility `cartesi-machine` are mostly useful for low-level tests and debugging.
As such, they require some context.

During verification, the blockchain mediates a *verification game* between the disputing parties.
This process is explained in detail under the [the blockchain perspective](../blockchain/vg.md).
In a nutshell, both parties started from a Cartesi Machine that has a known and agreed upon initial state hash.
(E.g., an agreed upon template that was instantiated with an agreed upon input drive.)
At the end of the computation, these parties now disagree on the state hash for the halted machine.
The state hash evolves as the machine executes steps in its fetch-execute loop.
The first stage of the verification game therefore searches for the *step of disagreement*: the particular cycle such that the parties agree on the state hash before the step, but disagree on the state hash after the step.
Once this step of disagreement is identified, one of the parties sends to the blockchain a log of state accesses that happen along the step, including cryptographic proofs for every value read from or written to the state.
This log proves to the blockchain that the execution of the step transitions the state in such a way that it reaches the state hash claimed by the submitting party.

The `--step` command-line option instructs `cartesi-machine` to dump to screen an abridged, user-friendly version of this state access log.

For the sake of completeness, consider the example in which we stopped the Cartesi Machine while it drew the splash screen.
The example below shows the step it was about to execute
```bash
playground:~$ cartesi-machine \
    --append-rom-bootargs="quiet" \
    --max-mcycle=695931 \
    --step > /dev/null
```
and produces the log
```
Building machine: please wait

Cycles: 695931
Gathering step proof: please wait
begin step
  hash 841eaf0e
  1: read iflags.H@0x1d0(464): 0x18(24)
  hash 841eaf0e
  2: read iflags.Y (superfluous)@0x1d0(464): 0x18(24)
  hash 841eaf0e
  3: write iflags.Y@0x1d0(464): 0x18(24) -> 0x18(24)
  begin raise_interrupt_if_any
    hash 841eaf0e
    4: read mip@0x170(368): 0x0(0)
    hash 841eaf0e
    5: read mie@0x168(360): 0x8(8)
  end raise_interrupt_if_any
  begin fetch_insn
    hash 841eaf0e
    6: read pc@0x100(256): 0x80002e8c(2147495564)
    begin translate_virtual_address
      hash 841eaf0e
      7: read iflags.PRV@0x1d0(464): 0x18(24)
      hash 841eaf0e
      8: read mstatus@0x130(304): 0xa00001800(42949679104)
    end translate_virtual_address
    begin find_pma_entry
      hash 841eaf0e
      9: read pma.istart@0x800(2048): 0x800000f9(2147483897)
      hash 841eaf0e
      10: read pma.ilength@0x808(2056): 0x4000000(67108864)
    end find_pma_entry
    hash 841eaf0e
    11: read memory@0x80002e88(2147495560): 0xa7b0231e47b783(47199985989040003)
  end fetch_insn
  begin sd
    hash 841eaf0e
    12: read x@0x78(120): 0x40008000(1073774592)
    hash 841eaf0e
    13: read x@0x50(80): 0x10100000000000a(72339069014638602)
    begin translate_virtual_address
      hash 841eaf0e
      14: read iflags.PRV@0x1d0(464): 0x18(24)
      hash 841eaf0e
      15: read mstatus@0x130(304): 0xa00001800(42949679104)
    end translate_virtual_address
    begin find_pma_entry
      hash 841eaf0e
      16: read pma.istart@0x800(2048): 0x800000f9(2147483897)
      hash 841eaf0e
      17: read pma.ilength@0x808(2056): 0x4000000(67108864)
      hash 841eaf0e
      18: read pma.istart@0x810(2064): 0x1069(4201)
      hash 841eaf0e
      19: read pma.ilength@0x818(2072): 0xf000(61440)
      hash 841eaf0e
      20: read pma.istart@0x820(2080): 0x80000000000002d9(9223372036854776537)
      hash 841eaf0e
      21: read pma.ilength@0x828(2088): 0x3c00000(62914560)
      hash 841eaf0e
      22: read pma.istart@0x830(2096): 0x4000841a(1073775642)
      hash 841eaf0e
      23: read pma.ilength@0x838(2104): 0x1000(4096)
    end find_pma_entry
    hash 841eaf0e
    24: write htif.tohost@0x40008000(1073774592): 0x10100000000000d(72339069014638605) -> 0x10100000000000a(72339069014638602)
    hash d24bec21
    25: write htif.fromhost@0x40008008(1073774600): 0x0(0) -> 0x101000000000000(72339069014638592)
    hash 2f707645
    26: write pc@0x100(256): 0x80002e8c(2147495564) -> 0x80002e90(2147495568)
  end sd
  hash d39b5b4d
  27: read minstret@0x128(296): 0xa9e7a(695930)
  hash d39b5b4d
  28: write minstret@0x128(296): 0xa9e7a(695930) -> 0xa9e7b(695931)
  hash a3294909
  29: read mcycle@0x120(288): 0xa9e7b(695931)
  hash a3294909
  30: write mcycle@0x120(288): 0xa9e7b(695931) -> 0xa9e7c(695932)
end step
```
Understanding these logs in detail is unnecessary for all but the most low-level internal development at Cartesi.
It requires deep knowledge of not only RISC-V architecture, but also how Cartesi's emulator implements it.
The material is beyond the scope of this document.
In this particular example, however, was hand-picked for illustration purposes.
The RISC-V instruction being executed, `sd`, writes the 64-bit word `0x010100000000000a` to address `0x40008000` (access&nbsp;#24).
This is the memory-mapped address of HTIF's `tohost` CSR.
The value refers to the console subdevice (`DEV=0x01`) , command `putchar` (`CMD=0x01`), and causes the device to output a line-feed (`DATA=0x0a`).
I.e., the instruction is completing the row `       \    / CARTESI` in the splash screen.

The command-line option `--json-log=<filename>` outputs a machine-readable version of the step log *for each cycle* executed by the emulator.
It is used by internal integration tests that verify the consistency between the Cartesi Machine as implemented by the off-chain emulator and as implemented by the on-chain step verification function.
Needless to say, even for brief computations, the resulting log files can be *very* large.
